!function () { function Y(e, t, a) { if (!(this instanceof Y)) return new Y(e, t, a); this.el = J, this.events = {}, this.maskset = J, !(this.refreshValue = !1) !== a && (q.isPlainObject(e) ? t = e : (t = t || {}).alias = e, this.opts = q.extend(!0, {}, this.defaults, t), this.noMasksCache = t && t.definitions !== J, this.userOptions = t || {}, this.isRTL = this.opts.numericInput, u(this.opts.alias, t, this.opts)) } function u(e, t, a) { var n = Y.prototype.aliases[e]; return n ? (n.alias && u(n.alias, J, a), q.extend(!0, a, n), q.extend(!0, a, t), 1) : (null === a.mask && (a.mask = e), 0) } function r(a, s) { function e(e, t, a) { var n, i = !1; null !== e && "" !== e || (e = (i = null !== a.regex) ? (e = a.regex).replace(/^(\^)(.*)(\$)$/, "$2") : "*{*}"), 1 === e.length && !1 === a.greedy && 0 !== a.repeat && (a.placeholder = ""), (0 < a.repeat || "*" === a.repeat || "+" === a.repeat) && (n = "*" === a.repeat ? 0 : "+" === a.repeat ? 1 : a.repeat, e = a.groupmarker.start + e + a.groupmarker.end + a.quantifiermarker.start + n + "," + a.repeat + a.quantifiermarker.end); var r, o = i ? "regex_" + a.regex : a.numericInput ? e.split("").reverse().join("") : e; return Y.prototype.masksCache[o] === J || !0 === s ? (r = { mask: e, maskToken: Y.prototype.analyseMask(e, i, a), validPositions: {}, _buffer: J, buffer: J, tests: {}, metadata: t, maskLength: J }, !0 !== s && (Y.prototype.masksCache[o] = r, r = q.extend(!0, {}, Y.prototype.masksCache[o]))) : r = q.extend(!0, {}, Y.prototype.masksCache[o]), r } if (q.isFunction(a.mask) && (a.mask = a.mask(a)), q.isArray(a.mask)) { if (1 < a.mask.length) { a.keepStatic = null === a.keepStatic || a.keepStatic; var n = a.groupmarker.start; return q.each(a.numericInput ? a.mask.reverse() : a.mask, function (e, t) { 1 < n.length && (n += a.groupmarker.end + a.alternatormarker + a.groupmarker.start), t.mask === J || q.isFunction(t.mask) ? n += t : n += t.mask }), e(n += a.groupmarker.end, a.mask, a) } a.mask = a.mask.pop() } return a.mask && a.mask.mask !== J && !q.isFunction(a.mask.mask) ? e(a.mask.mask, a.mask, a) : e(a.mask, a.mask, a) } function $(e, F, G) { function f(e, t, a) { t = t || 0; var n, i, r, o = [], s = 0, l = A(); for (-1 === (K = U !== J ? U.maxLength : J) && (K = J); !0 === e && F.validPositions[s] ? (i = (r = F.validPositions[s]).match, n = r.locator.slice(), o.push(!0 === a ? r.input : !1 === a ? i.nativeDef : _(s, i))) : (i = (r = x(s, n, s - 1)).match, n = r.locator.slice(), (!1 === G.jitMasking || s < l || "number" == typeof G.jitMasking && isFinite(G.jitMasking) && G.jitMasking > s) && o.push(!1 === a ? i.nativeDef : _(s, i))), s++, (K === J || s < K) && (null !== i.fn || "" !== i.def) || s < t;); return "" === o[o.length - 1] && o.pop(), F.maskLength = s + 1, o } function w(e) { var t = F; t.buffer = J, !0 !== e && (t.validPositions = {}, t.p = 0) } function A(e, t, a) { var n = -1, i = -1, r = a || F.validPositions; for (var o in e === J && (e = -1), r) { var s = parseInt(o); r[s] && (t || !0 !== r[s].generatedInput) && (s <= e && (n = s), e <= s && (i = s)) } return -1 !== n && 1 < e - n || i < e ? n : i } function k(e, t, a, n) { var i, r, o = e, s = q.extend(!0, {}, F.validPositions), l = !1; for (F.p = e, i = t - 1; o <= i; i--)F.validPositions[i] !== J && (!0 !== a && (!F.validPositions[i].match.optionality && function () { var e = F.validPositions[i]; if (e !== J && null === e.match.fn) { var t = F.validPositions[i - 1], a = F.validPositions[i + 1]; return t !== J && a !== J } }() || !1 === G.canClearPosition(F, i, A(), n, G)) || delete F.validPositions[i]); for (w(!0), i = o + 1; i <= A();) { for (; F.validPositions[o] !== J;)o++; i < o && (i = o + 1), F.validPositions[i] === J && M(i) ? i++ : (r = x(i), !1 === l && s[o] && s[o].match.def === r.match.def ? (F.validPositions[o] = q.extend(!0, {}, s[o]), F.validPositions[o].input = r.input, delete F.validPositions[i], i++) : b(o, r.match.def) ? !1 !== O(o, r.input || _(i), !0) && (delete F.validPositions[i], i++, l = !0) : M(i) || (i++, o--), o++) } w(!0) } function d(e, t) { for (var a, n = e, i = A(), r = F.validPositions[i] || S(0)[0], o = r.alternation !== J ? r.locator[r.alternation].toString().split(",") : [], s = 0; s < n.length && (!((a = n[s]).match && (G.greedy && !0 !== a.match.optionalQuantifier || (!1 === a.match.optionality || !1 === a.match.newBlockMarker) && !0 !== a.match.optionalQuantifier) && (r.alternation === J || r.alternation !== a.alternation || a.locator[r.alternation] !== J && m(a.locator[r.alternation].toString().split(","), o))) || !0 === t && (null !== a.match.fn || /[0-9a-bA-Z]/.test(a.match.def))); s++); return a } function x(e, t, a) { return F.validPositions[e] || d(S(e, t ? t.slice() : t, a)) } function g(e) { return F.validPositions[e] ? F.validPositions[e] : S(e)[0] } function b(e, t) { for (var a = !1, n = S(e), i = 0; i < n.length; i++)if (n[i].match && n[i].match.def === t) { a = !0; break } return a } function S(M, e, t) { function R(E, C, e, t) { function O(e, a, t) { function r(a, n) { var i = 0 === q.inArray(a, n.matches); return i || q.each(n.matches, function (e, t) { if (!0 === t.isQuantifier && (i = r(a, n.matches[e - 1]))) return !1 }), i } function l(e, i, r) { var o, s; if (F.validPositions[e - 1] && r && F.tests[e]) for (var t = F.validPositions[e - 1].locator, a = F.tests[e][0].locator, n = 0; n < r; n++)if (t[n] !== a[n]) return t[r]; return (F.tests[e] || F.validPositions[e]) && q.each(F.tests[e] || [F.validPositions[e]], function (e, t) { var a = r !== J ? r : t.alternation, n = t.locator[a] !== J ? t.locator[a].toString().indexOf(i) : -1; (s === J || n < s) && -1 !== n && (o = t, s = n) }), o ? o.locator.slice((r !== J ? r : o.alternation) + 1) : r !== J ? l(e, i) : J } if (1e4 < D) throw "Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. " + F.mask; if (D === M && e.matches === J) return I.push({ match: e, locator: a.reverse(), cd: N }), !0; if (e.matches !== J) { if (e.isGroup && t !== e) { if (e = O(E.matches[q.inArray(e, E.matches) + 1], a)) return !0 } else if (e.isOptional) { var n = e; if (e = R(e, C, a, t)) { if (!r(_ = I[I.length - 1].match, n)) return !0; j = !0, D = M } } else if (e.isAlternator) { var i, o = e, s = [], c = I.slice(), u = a.length, p = 0 < C.length ? C.shift() : -1; if (-1 === p || "string" == typeof p) { var f = D, d = C.slice(), m = []; if ("string" == typeof p) m = p.split(","); else for (v = 0; v < o.matches.length; v++)m.push(v); for (var h = 0; h < m.length; h++) { var g, v = parseInt(m[h]); I = [], C = l(D, v, u) || d.slice(), !0 !== (e = O(o.matches[v] || E.matches[v], [v].concat(a), t) || e) && e !== J && m[m.length - 1] < o.matches.length && (g = q.inArray(e, E.matches) + 1, E.matches.length > g && (e = O(E.matches[g], [g].concat(a.slice(1, a.length)), t)) && (m.push(g.toString()), q.each(I, function (e, t) { t.alternation = a.length - 1 }))), i = I.slice(), D = f, I = []; for (var y = 0; y < i.length; y++) { var k = i[y], x = !1; k.alternation = k.alternation || u; for (var b = 0; b < s.length; b++) { var P = s[b]; if ("string" != typeof p || -1 !== q.inArray(k.locator[k.alternation].toString(), m)) { if (k.match.nativeDef === P.match.nativeDef || k.match.def === P.match.nativeDef || k.match.nativeDef === P.match.def) { x = !0, k.alternation == P.alternation && -1 === P.locator[P.alternation].toString().indexOf(k.locator[k.alternation]) && (P.locator[P.alternation] = P.locator[P.alternation] + "," + k.locator[k.alternation], P.alternation = k.alternation), k.match.nativeDef === P.match.def && (k.locator[k.alternation] = P.locator[P.alternation], s.splice(s.indexOf(P), 1, k)); break } if (k.match.def === P.match.def) { x = !1; break } if (null === k.match.fn && null !== P.match.fn && P.match.fn.test(k.match.def, F, M, !1, G, !1) || null !== k.match.fn && null !== P.match.fn && P.match.fn.test(k.match.def.replace(/[\[\]]/g, ""), F, M, !1, G, !1)) { k.alternation == P.alternation && -1 === k.locator[k.alternation].toString().indexOf(P.locator[P.alternation].toString().split("")[0]) && (k.na = k.na || k.locator[k.alternation].toString(), -1 === k.na.indexOf(k.locator[k.alternation].toString().split("")[0]) && (k.na = k.na + "," + k.locator[P.alternation].toString().split("")[0]), x = !0, k.locator[k.alternation] = P.locator[P.alternation].toString().split("")[0] + "," + k.locator[k.alternation], s.splice(s.indexOf(P), 0, k)); break } } } x || s.push(k) } } "string" == typeof p && (s = q.map(s, function (e, t) { if (isFinite(t)) { var a = e.alternation, n = e.locator[a].toString().split(","); e.locator[a] = J, e.alternation = J; for (var i = 0; i < n.length; i++)-1 !== q.inArray(n[i], m) && (e.locator[a] !== J ? (e.locator[a] += ",", e.locator[a] += n[i]) : e.locator[a] = parseInt(n[i]), e.alternation = a); if (e.locator[a] !== J) return e } })), I = c.concat(s), D = M, j = 0 < I.length, e = 0 < s.length, C = d.slice() } else e = O(o.matches[p] || E.matches[p], [p].concat(a), t); if (e) return !0 } else if (e.isQuantifier && t !== E.matches[q.inArray(e, E.matches) - 1]) for (var w = e, A = 0 < C.length ? C.shift() : 0; A < (isNaN(w.quantifier.max) ? A + 1 : w.quantifier.max) && D <= M; A++) { var S = E.matches[q.inArray(w, E.matches) - 1]; if (e = O(S, [A].concat(a), S)) { if ((_ = I[I.length - 1].match).optionalQuantifier = A > w.quantifier.min - 1, r(_, S)) { if (A > w.quantifier.min - 1) { j = !0, D = M; break } return !0 } return !0 } } else if (e = R(e, C, a, t)) return !0 } else D++ } for (var a = 0 < C.length ? C.shift() : 0; a < E.matches.length; a++)if (!0 !== E.matches[a].isQuantifier) { var n = O(E.matches[a], [a].concat(e), t); if (n && D === M) return n; if (M < D) break } } function a(e) { return G.keepStatic && 0 < M && e.length > 1 + ("" === e[e.length - 1].match.def ? 1 : 0) && !0 !== e[0].match.optionality && !0 !== e[0].match.optionalQuantifier && null === e[0].match.fn && !/[0-9a-bA-Z]/.test(e[0].match.def) ? [d(e)] : e } var _, n, i, r = F.maskToken, D = e ? t : 0, o = e ? e.slice() : [0], I = [], j = !1, N = e ? e.join("") : ""; if (-1 < M) { if (e === J) { for (var s, l = M - 1; (s = F.validPositions[l] || F.tests[l]) === J && -1 < l;)l--; s !== J && -1 < l && (n = s, i = [], q.isArray(n) || (n = [n]), 0 < n.length && (n[0].alternation === J ? 0 === (i = d(n.slice()).locator.slice()).length && (i = n[0].locator.slice()) : q.each(n, function (e, t) { if ("" !== t.def) if (0 === i.length) i = t.locator.slice(); else for (var a = 0; a < i.length; a++)t.locator[a] && -1 === i[a].toString().indexOf(t.locator[a]) && (i[a] += "," + t.locator[a]) })), N = (o = i).join(""), D = l) } if (F.tests[M] && F.tests[M][0].cd === N) return a(F.tests[M]); for (var c = o.shift(); c < r.length && !(R(r[c], o, [c]) && D === M || M < D); c++); } return 0 !== I.length && !j || I.push({ match: { fn: null, cardinality: 0, optionality: !0, casing: null, def: "", placeholder: "" }, locator: [], cd: N }), e !== J && F.tests[M] ? a(q.extend(!0, [], I)) : (F.tests[M] = q.extend(!0, [], I), a(F.tests[M])) } function y() { return F._buffer === J && (F._buffer = f(!1, 1), F.buffer === J && (F.buffer = F._buffer.slice())), F._buffer } function E(e) { return F.buffer !== J && !0 !== e || (F.buffer = f(!0, A(), !0)), F.buffer } function C(e, t, a) { var n, i, r; if (!0 === e) w(), e = 0, t = a.length; else for (n = e; n < t; n++)delete F.validPositions[n]; for (n = i = e; n < t; n++) { w(!0), a[n] !== G.skipOptionalPartCharacter && !1 !== (r = O(i, a[n], !0, !0)) && (w(!0), i = r.caret !== J ? r.caret : r.pos + 1) } } function m(e, t, a) { for (var n, i = G.greedy ? t : t.slice(0, 1), r = !1, o = a !== J ? a.split(",") : [], s = 0; s < o.length; s++)-1 !== (n = e.indexOf(o[s])) && e.splice(n, 1); for (var l = 0; l < e.length; l++)if (-1 !== q.inArray(e[l], i)) { r = !0; break } return r } function O(h, e, t, P, a) { function g(e) { var t = H ? 1 < e.begin - e.end || e.begin - e.end == 1 : 1 < e.end - e.begin || e.end - e.begin == 1; return t && 0 === e.begin && e.end === F.maskLength ? "full" : t } function i(p, f, d) { var m = !1; return q.each(S(p), function (e, t) { for (var a, n = t.match, i = f ? 1 : 0, r = "", o = n.cardinality; i < o; o--)r += (a = p - (o - 1), F.validPositions[a] === J ? _(a) : F.validPositions[a].input); if (f && (r += f), E(!0), !1 !== (m = null != n.fn ? n.fn.test(r, F, p, d, G, g(h)) : (f === n.def || f === G.skipOptionalPartCharacter) && "" !== n.def && { c: _(p, n, !0) || n.def, pos: p })) { var s = (s = m.c !== J ? m.c : f) === G.skipOptionalPartCharacter && null === n.fn ? _(p, n, !0) || n.def : s, l = p, c = E(); if (m.remove !== J && (q.isArray(m.remove) || (m.remove = [m.remove]), q.each(m.remove.sort(function (e, t) { return t - e }), function (e, t) { k(t, t + 1, !0) })), m.insert !== J && (q.isArray(m.insert) || (m.insert = [m.insert]), q.each(m.insert.sort(function (e, t) { return e - t }), function (e, t) { O(t.pos, t.c, !0, P) })), m.refreshFromBuffer) { var u = m.refreshFromBuffer; if (C(!0 === u ? u : u.start, u.end, c), m.pos === J && m.c === J) return m.pos = A(), !1; if ((l = m.pos !== J ? m.pos : p) !== p) return m = q.extend(m, O(l, s, !0, P)), !1 } else if (!0 !== m && m.pos !== J && m.pos !== p && (l = m.pos, C(p, l, E().slice()), l !== p)) return m = q.extend(m, O(l, s, !0)), !1; return (!0 === m || m.pos !== J || m.c !== J) && (0 < e && w(!0), v(l, q.extend({}, t, { input: function (e, t, a) { switch (G.casing || t.casing) { case "upper": e = e.toUpperCase(); break; case "lower": e = e.toLowerCase(); break; case "title": var n = F.validPositions[a - 1]; e = 0 === a || n && n.input === String.fromCharCode(Y.keyCode.SPACE) ? e.toUpperCase() : e.toLowerCase() }return e }(s, n, l) }), P, g(h)) || (m = !1), !1) } }), m } function v(e, t, a, n) { if (n || G.insertMode && F.validPositions[e] !== J && a === J) { for (var i = q.extend(!0, {}, F.validPositions), r = A(J, !0), o = e; o <= r; o++)delete F.validPositions[o]; F.validPositions[e] = q.extend(!0, {}, t); var s = !0, l = F.validPositions, c = !1, u = F.maskLength; for (o = m = e; o <= r; o++) { var p = i[o]; if (p !== J) for (var f = m; f < F.maskLength && (null === p.match.fn && l[o] && (!0 === l[o].match.optionalQuantifier || !0 === l[o].match.optionality) || null != p.match.fn);) { if (f++, !1 === c && i[f] && i[f].match.def === p.match.def) F.validPositions[f] = q.extend(!0, {}, i[f]), F.validPositions[f].input = p.input, y(f), m = f, s = !0; else if (b(f, p.match.def)) var d = O(f, p.input, !0, !0), s = !1 !== d, m = d.caret || d.insert ? A() : f, c = !0; else if (!(s = !0 === p.generatedInput) && f >= F.maskLength - 1) break; if (F.maskLength < u && (F.maskLength = u), s) break } if (!s) break } if (!s) return F.validPositions = q.extend(!0, {}, i), w(!0), 0 } else F.validPositions[e] = q.extend(!0, {}, t); return w(!0), 1 } function y(e) { for (var t, a, n = e - 1; -1 < n && !F.validPositions[n]; n--); for (n++; n < e; n++)F.validPositions[n] === J && (!1 === G.jitMasking || G.jitMasking > n) && ("" === (a = S(n, x(n - 1).locator, n - 1).slice())[a.length - 1].match.def && a.pop(), (t = d(a)) && (t.match.def === G.radixPointDefinitionSymbol || !M(n, !0) || q.inArray(G.radixPoint, E()) < n && t.match.fn && t.match.fn.test(_(n), F, n, !1, G)) && !1 !== (s = i(n, _(n, t.match, !0) || (null == t.match.fn ? t.match.def : "" !== _(n) ? _(n) : E()[n]), !0)) && (F.validPositions[s.pos || n].generatedInput = !0)) } t = !0 === t; var r = h; h.begin !== J && (r = H && !g(h) ? h.end : h.begin); var n, o, s = !0, l = q.extend(!0, {}, F.validPositions); if (q.isFunction(G.preValidation) && !t && !0 !== P && (s = G.preValidation(E(), r, e, g(h), G)), !0 === s) { if (y(r), g(h) && (T(J, Y.keyCode.DELETE, h), r = F.p), r < F.maskLength && (K === J || r < K) && (s = i(r, e, t), (!t || !0 === P) && !1 === s)) { var c = F.validPositions[r]; if (!c || null !== c.match.fn || c.match.def !== e && e !== G.skipOptionalPartCharacter) { if ((G.insertMode || F.validPositions[R(r)] === J) && !M(r, !0)) for (var u = r + 1, p = R(r); u <= p; u++)if (!1 !== (s = i(u, e, t))) { !function (e) { var t, o, s, a = F.validPositions[e]; if (a) for (var l = a.locator, c = l.length, n = r; n < e; n++) { F.validPositions[n] !== J || M(n, !0) || (t = S(n).slice(), o = d(t, !0), s = -1, "" === t[t.length - 1].match.def && t.pop(), q.each(t, function (e, t) { for (var a = 0; a < c; a++) { if (t.locator[a] === J || !m(t.locator[a].toString().split(","), l[a].toString().split(","), t.na)) { var n = l[a], i = o.locator[a], r = t.locator[a]; n - i > Math.abs(n - r) && (o = t); break } s < a && (s = a, o = t) } }), (o = q.extend({}, o, { input: _(n, o.match, !0) || o.match.def })).generatedInput = !0, v(n, o, !0), F.validPositions[e] = J, i(e, a.input, !0)) } }(s.pos !== J ? s.pos : u), r = u; break } } else s = { caret: R(r) } } !1 === s && G.keepStatic && !t && !0 !== a && (s = function (u, p, f) { for (var e, d, t, m, h, g, v, y, k, a, x = q.extend(!0, {}, F.validPositions), b = !1, n = A(), i = F.validPositions[n]; 0 <= n; n--)if ((t = F.validPositions[n]) && t.alternation !== J) { if (e = n, d = F.validPositions[e].alternation, i.locator[t.alternation] !== t.locator[t.alternation]) break; i = t } return d !== J && (v = parseInt(e), 0 < (y = i.locator[i.alternation || d] !== J ? i.locator[i.alternation || d] : g[0]).length && (y = y.split(",")[0]), k = F.validPositions[v], a = F.validPositions[v - 1], q.each(S(v, a ? a.locator : J, v - 1), function (e, t) { g = t.locator[d] ? t.locator[d].toString().split(",") : []; for (var a = 0; a < g.length; a++) { var n = [], i = 0, r = 0, o = !1; if (y < g[a] && (t.na === J || -1 === q.inArray(g[a], t.na.split(",")) || -1 === q.inArray(y.toString(), g))) { F.validPositions[v] = q.extend(!0, {}, t); var s = F.validPositions[v].locator; for (F.validPositions[v].locator[d] = parseInt(g[a]), null == t.match.fn ? (k.input !== t.match.def && ((o = !0) !== k.generatedInput && n.push(k.input)), r++, F.validPositions[v].generatedInput = !/[0-9a-bA-Z]/.test(t.match.def), F.validPositions[v].input = t.match.def) : F.validPositions[v].input = k.input, m = v + 1; m < A(J, !0) + 1; m++)(h = F.validPositions[m]) && !0 !== h.generatedInput && /[0-9a-bA-Z]/.test(h.input) ? n.push(h.input) : m < u && i++, delete F.validPositions[m]; for (o && n[0] === t.match.def && n.shift(), w(!0), b = !0; 0 < n.length;) { var l = n.shift(); if (l !== G.skipOptionalPartCharacter && !(b = O(A(J, !0) + 1, l, !1, P, !0))) break } if (b) { F.validPositions[v].locator = s; var c = A(u) + 1; for (m = v + 1; m < A() + 1; m++)((h = F.validPositions[m]) === J || null == h.match.fn) && m < u + (r - i) && r++; b = O(c < (u += r - i) ? c : u, p, f, P, !0) } if (b) return !1; w(), F.validPositions = q.extend(!0, {}, x) } } })), b }(r, e, t)), !0 === s && (s = { pos: r }) } return q.isFunction(G.postValidation) && !1 !== s && !t && !0 !== P && ((n = G.postValidation(E(!0), s, G)).refreshFromBuffer && n.buffer && C(!0 === (o = n.refreshFromBuffer) ? o : o.start, o.end, n.buffer), s = !0 === n ? s : n), s.pos === J && (s.pos = r), !1 === s && (w(!0), F.validPositions = q.extend(!0, {}, l)), s } function M(e, t) { var a = x(e).match; if ("" === a.def && (a = g(e).match), null != a.fn) return a.fn; if (!0 !== t && -1 < e) { var n = S(e); return n.length > 1 + ("" === n[n.length - 1].match.def ? 1 : 0) } } function R(e, t) { var a = F.maskLength; if (a <= e) return a; var n = e; for (1 < S(a + 1).length && (f(!0, a + 1, !0), a = F.maskLength); ++n < a && (!0 === t && (!0 !== g(n).match.newBlockMarker || !M(n)) || !0 !== t && !M(n));); return n } function v(e, t) { var a, n = e; if (n <= 0) return 0; for (; 0 < --n && (!0 === t && !0 !== g(n).match.newBlockMarker || !0 !== t && !M(n) && ((a = S(n)).length < 2 || 2 === a.length && "" === a[1].match.def));); return n } function P(e, t, a, n, i) { var r, o; n && q.isFunction(G.onBeforeWrite) && ((r = G.onBeforeWrite(n, t, a, G)) && (r.refreshFromBuffer && (C(!0 === (o = r.refreshFromBuffer) ? o : o.start, o.end, r.buffer || t), t = E(!0)), a !== J && (a = r.caret !== J ? r.caret : a))), e !== J && (e.inputmask._valueSet(t.join("")), a === J || n !== J && "blur" === n.type ? p(e, t, a) : ne && "input" === n.type ? setTimeout(function () { I(e, a) }, 0) : I(e, a), !0 === i && (l = !0, q(e).trigger("input"))) } function _(e, t, a) { if ((t = t || g(e).match).placeholder !== J || !0 === a) return q.isFunction(t.placeholder) ? t.placeholder(G) : t.placeholder; if (null !== t.fn) return G.placeholder.charAt(e % G.placeholder.length); if (-1 < e && F.validPositions[e] === J) { var n, i = S(e), r = []; if (i.length > 1 + ("" === i[i.length - 1].match.def ? 1 : 0)) for (var o = 0; o < i.length; o++)if (!0 !== i[o].match.optionality && !0 !== i[o].match.optionalQuantifier && (null === i[o].match.fn || n === J || !1 !== i[o].match.fn.test(n.match.def, F, e, !0, G)) && (r.push(i[o]), null === i[o].match.fn && (n = i[o]), 1 < r.length && /[0-9a-bA-Z]/.test(r[0].match.def))) return G.placeholder.charAt(e % G.placeholder.length) } return t.def } function D(p, e, f, t, a) { var n, i, r, o = t.slice(), d = "", m = 0, h = J; w(), F.p = R(-1), f || (!0 !== G.autoUnmask ? (n = y().slice(0, R(-1)).join(""), (i = o.join("").match(new RegExp("^" + Y.escapeRegex(n), "g"))) && 0 < i.length && (o.splice(0, i.length * n.length), m = R(m))) : m = R(m)), q.each(o, function (e, t) { var a, n, i, r, o, s, l, c, u; t !== J && ((a = new q.Event("_checkval")).which = t.charCodeAt(0), d += t, r = x((n = A(J, !0)) + 1, (i = F.validPositions[n]) ? i.locator.slice() : J, n), c = m, u = d, -1 === y().slice(c, R(c)).join("").indexOf(u) || M(c) || g(c).match.nativeDef !== u.charAt(u.length - 1) || f || G.autoUnmask ? (o = f ? e : null == r.match.fn && r.match.optionality && n + 1 < F.p ? n + 1 : F.p, h = Q.keypressEvent.call(p, a, !0, !1, f, o), m = o + 1, d = "") : h = Q.keypressEvent.call(p, a, !0, !1, !0, n + 1), !f && q.isFunction(G.onBeforeWrite) && (s = h.forwardPosition, (h = G.onBeforeWrite(a, E(), h.forwardPosition, G)).forwardPosition = s, h && h.refreshFromBuffer && (C(!0 === (l = h.refreshFromBuffer) ? l : l.start, l.end, h.buffer), w(!0), h.caret && (F.p = h.caret, h.forwardPosition = h.caret)))) }), e && (r = J, X.activeElement === p && h && (r = G.numericInput ? v(h.forwardPosition) : h.forwardPosition), P(p, E(), r, a || new q.Event("checkval"), a && "input" === a.type)) } function t(e) { if (e) { if (e.inputmask === J) return e.value; e.inputmask && e.inputmask.refreshValue && Q.setValueEvent.call(e) } var t = [], a = F.validPositions; for (var n in a) a[n].match && null != a[n].match.fn && t.push(a[n].input); var i, r = 0 === t.length ? "" : (H ? t.reverse() : t).join(""); return q.isFunction(G.onUnMask) && (i = (H ? E().slice().reverse() : E()).join(""), r = G.onUnMask(i, r, G)), r } function I(e, t, a, n) { function i(e) { return !0 === n || !H || "number" != typeof e || G.greedy && "" === G.placeholder || (e = E().join("").length - e), e } var r, o, s, l; if (t === J) return e.setSelectionRange ? (t = e.selectionStart, a = e.selectionEnd) : Z.getSelection ? (s = Z.getSelection().getRangeAt(0)).commonAncestorContainer.parentNode !== e && s.commonAncestorContainer !== e || (t = s.startOffset, a = s.endOffset) : X.selection && X.selection.createRange && (a = (t = 0 - (s = X.selection.createRange()).duplicate().moveStart("character", -e.inputmask._valueGet().length)) + s.text.length), { begin: i(t), end: i(a) }; t.begin !== J && (a = t.end, t = t.begin), "number" == typeof t && (t = i(t), a = "number" == typeof (a = i(a)) ? a : t, r = parseInt(((e.ownerDocument.defaultView || Z).getComputedStyle ? (e.ownerDocument.defaultView || Z).getComputedStyle(e, null) : e.currentStyle).fontSize) * a, e.scrollLeft = r > e.scrollWidth ? r : 0, ee || !1 !== G.insertMode || t !== a || a++, e.setSelectionRange ? (e.selectionStart = t, e.selectionEnd = a) : Z.getSelection ? (s = X.createRange(), e.firstChild !== J && null !== e.firstChild || (o = X.createTextNode(""), e.appendChild(o)), s.setStart(e.firstChild, t < e.inputmask._valueGet().length ? t : e.inputmask._valueGet().length), s.setEnd(e.firstChild, a < e.inputmask._valueGet().length ? a : e.inputmask._valueGet().length), s.collapse(!0), (l = Z.getSelection()).removeAllRanges(), l.addRange(s)) : e.createTextRange && ((s = e.createTextRange()).collapse(!0), s.moveEnd("character", a), s.moveStart("character", t), s.select()), p(e, J, { begin: t, end: a })) } function o(e) { for (var t, a = E(), n = a.length, i = A(), r = {}, o = F.validPositions[i], s = o !== J ? o.locator.slice() : J, l = i + 1; l < a.length; l++)s = (t = x(l, s, l - 1)).locator.slice(), r[l] = q.extend(!0, {}, t); var c = o && o.alternation !== J ? o.locator[o.alternation] : J; for (l = n - 1; i < l && (((t = r[l]).match.optionality || t.match.optionalQuantifier && t.match.newBlockMarker || c && (c !== r[l].locator[o.alternation] && null != t.match.fn || null === t.match.fn && t.locator[o.alternation] && m(t.locator[o.alternation].toString().split(","), c.toString().split(",")) && "" !== S(l)[0].def)) && a[l] === _(l, t.match)); l--)n--; return e ? { l: n, def: r[n] ? r[n].match : J } : n } function j(e) { for (var t, a = o(), n = e.length, i = F.validPositions[A()]; a < n && !M(a, !0) && (t = i !== J ? x(a, i.locator.slice(""), i) : g(a)) && !0 !== t.match.optionality && (!0 !== t.match.optionalQuantifier && !0 !== t.match.newBlockMarker || a + 1 === n && "" === (i !== J ? x(a + 1, i.locator.slice(""), i) : g(a + 1)).match.def);)a++; for (; (t = F.validPositions[a - 1]) && t && t.match.optionality && t.input === G.skipOptionalPartCharacter;)a--; return e.splice(a), e } function N(e) { if (q.isFunction(G.isComplete)) return G.isComplete(e, G); if ("*" === G.repeat) return J; var t = !1, a = o(!0), n = v(a.l); if (a.def === J || a.def.newBlockMarker || a.def.optionality || a.def.optionalQuantifier) { t = !0; for (var i = 0; i <= n; i++) { var r = x(i).match; if (null !== r.fn && F.validPositions[i] === J && !0 !== r.optionality && !0 !== r.optionalQuantifier || null === r.fn && e[i] !== _(i, r)) { t = !1; break } } } return t } function T(o, e, t, a) { var n; (G.numericInput || H) && (e === Y.keyCode.BACKSPACE ? e = Y.keyCode.DELETE : e === Y.keyCode.DELETE && (e = Y.keyCode.BACKSPACE), H) && (n = t.end, t.end = t.begin, t.begin = n), e === Y.keyCode.BACKSPACE && (t.end - t.begin < 1 || !1 === G.insertMode) ? (t.begin = v(t.begin), F.validPositions[t.begin] === J || F.validPositions[t.begin].input !== G.groupSeparator && F.validPositions[t.begin].input !== G.radixPoint || t.begin--) : e === Y.keyCode.DELETE && t.begin === t.end && (t.end = M(t.end, !0) ? t.end + 1 : R(t.end) + 1, F.validPositions[t.begin] === J || F.validPositions[t.begin].input !== G.groupSeparator && F.validPositions[t.begin].input !== G.radixPoint || t.end++), k(t.begin, t.end, !1, a), !0 !== a && function () { if (G.keepStatic) { for (var e = [], t = A(-1, !0), a = q.extend(!0, {}, F.validPositions), n = F.validPositions[t]; 0 <= t; t--) { var i = F.validPositions[t]; if (i) { if (!0 !== i.generatedInput && /[0-9a-bA-Z]/.test(i.input) && e.push(i.input), delete F.validPositions[t], i.alternation !== J && i.locator[i.alternation] !== n.locator[i.alternation]) break; n = i } } if (-1 < t) for (F.p = R(A(-1, !0)); 0 < e.length;) { var r = new q.Event("keypress"); r.which = e.pop().charCodeAt(0), Q.keypressEvent.call(o, r, !0, !1, !1, F.p) } else F.validPositions = q.extend(!0, {}, a) } }(); var i = A(t.begin, !0); i < t.begin ? F.p = R(i) : !0 !== a && (F.p = t.begin) } function B(c) { function t() { h.style.position = "absolute", h.style.top = a.top + "px", h.style.left = a.left + "px", h.style.width = parseInt(c.offsetWidth) - parseInt(u.paddingLeft) - parseInt(u.paddingRight) - parseInt(u.borderLeftWidth) - parseInt(u.borderRightWidth) + "px", h.style.height = parseInt(c.offsetHeight) - parseInt(u.paddingTop) - parseInt(u.paddingBottom) - parseInt(u.borderTopWidth) - parseInt(u.borderBottomWidth) + "px", h.style.lineHeight = h.style.height, h.style.zIndex = isNaN(u.zIndex) ? -1 : u.zIndex - 1, h.style.webkitAppearance = "textfield", h.style.mozAppearance = "textfield", h.style.Appearance = "textfield" } var a = q(c).position(), u = (c.ownerDocument.defaultView || Z).getComputedStyle(c, null); for (var e in c.parentNode, h = X.createElement("div"), X.body.appendChild(h), u) u.hasOwnProperty(e) && isNaN(e) && "cssText" !== e && -1 == e.indexOf("webkit") && (h.style[e] = u[e]); c.style.backgroundColor = "transparent", c.style.color = "transparent", c.style.webkitAppearance = "caret", c.style.mozAppearance = "caret", c.style.Appearance = "caret", t(), q(Z).on("resize", function (e) { a = q(c).position(), u = (c.ownerDocument.defaultView || Z).getComputedStyle(c, null), t() }), q(c).on("click", function (e) { return I(c, function (e) { var t = X.createElement("span"); for (var a in u) isNaN(a) && -1 !== a.indexOf("font") && (t.style[a] = u[a]); t.style.textTransform = u.textTransform, t.style.letterSpacing = u.letterSpacing, t.style.position = "absolute", t.style.height = "auto", t.style.width = "auto", t.style.visibility = "hidden", t.style.whiteSpace = "nowrap", X.body.appendChild(t); for (var n = c.inputmask._valueGet(), i = 0, r = 0, o = n.length; r <= o; r++) { if (t.innerHTML += n.charAt(r) || "_", t.offsetWidth >= e) { var s = e - i, l = t.offsetWidth - e; t.innerHTML = n.charAt(r), r = (s -= t.offsetWidth / 3) < l ? r - 1 : r; break } i = t.offsetWidth } return X.body.removeChild(t), r }(e.clientX)), Q.clickEvent.call(this, [e]) }), q(c).on("keydown", function (e) { e.shiftKey || !1 === G.insertMode || setTimeout(function () { p(c) }, 0) }) } function p(e, t, a) { function n() { r || null !== s.fn && l.input !== J ? r && null !== s.fn && l.input !== J && (r = !1, i += "</span>") : (r = !0, i += "<span class='im-static''>") } if (h !== J) { t = t || E(), a === J ? a = I(e) : a.begin === J && (a = { begin: a, end: a }); var i = "", r = !1; if ("" != t) for (var o, s, l, c = 0, u = A(); c === a.begin && X.activeElement === e && (i += "<span class='im-caret' style='border-right-width: 1px;border-right-style: solid;'></span>"), F.validPositions[c] ? (l = F.validPositions[c], s = l.match, o = l.locator.slice(), n(), i += l.input) : (l = x(c, o, c - 1), s = l.match, o = l.locator.slice(), (!1 === G.jitMasking || c < u || "number" == typeof G.jitMasking && isFinite(G.jitMasking) && G.jitMasking > c) && (n(), i += _(c, s))), c++, (K === J || c < K) && (null !== s.fn || "" !== s.def) || c < u;); h.innerHTML = i } } F = F || this.maskset, G = G || this.opts; var L, V, K, h, a, U = this.el, H = this.isRTL, s = !1, l = !1, W = !1, n = !1, z = { on: function (e, t, r) { function a(e) { if (this.inputmask === J && "FORM" !== this.nodeName) { var t = q.data(this, "_inputmask_opts"); t ? new Y(t).mask(this) : z.off(this) } else { if ("setvalue" === e.type || "FORM" === this.nodeName || !(this.disabled || this.readOnly && !("keydown" === e.type && e.ctrlKey && 67 === e.keyCode || !1 === G.tabThrough && e.keyCode === Y.keyCode.TAB))) { switch (e.type) { case "input": if (!0 === l) return l = !1, e.preventDefault(); break; case "keydown": l = s = !1; break; case "keypress": if (!0 === s) return e.preventDefault(); s = !0; break; case "click": if (te || ae) { var a = this, n = arguments; return setTimeout(function () { r.apply(a, n) }, 0), !1 } }var i = r.apply(this, arguments); return !1 === i && (e.preventDefault(), e.stopPropagation()), i } e.preventDefault() } } e.inputmask.events[t] = e.inputmask.events[t] || [], e.inputmask.events[t].push(a), -1 !== q.inArray(t, ["submit", "reset"]) ? null != e.form && q(e.form).on(t, a) : q(e).on(t, a) }, off: function (n, e) { var t; n.inputmask && n.inputmask.events && (e ? (t = [])[e] = n.inputmask.events[e] : t = n.inputmask.events, q.each(t, function (e, t) { for (; 0 < t.length;) { var a = t.pop(); -1 !== q.inArray(e, ["submit", "reset"]) ? null != n.form && q(n.form).off(e, a) : q(n).off(e, a) } delete n.inputmask.events[e] })) } }, Q = { keydownEvent: function (e) { var t, a, n, i, r = this, o = q(r), s = e.keyCode, l = I(r); s === Y.keyCode.BACKSPACE || s === Y.keyCode.DELETE || ae && s === Y.keyCode.BACKSPACE_SAFARI || e.ctrlKey && s === Y.keyCode.X && (a = X.createElement("input"), (i = (n = "oncut") in a) || (a.setAttribute(n, "return;"), i = "function" == typeof a[n]), a = null, !i) ? (e.preventDefault(), T(r, s, l), P(r, E(!0), F.p, e, r.inputmask._valueGet() !== E().join("")), r.inputmask._valueGet() === y().join("") ? o.trigger("cleared") : !0 === N(E()) && o.trigger("complete")) : s === Y.keyCode.END || s === Y.keyCode.PAGE_DOWN ? (e.preventDefault(), t = R(A()), G.insertMode || t !== F.maskLength || e.shiftKey || t--, I(r, e.shiftKey ? l.begin : t, t, !0)) : s === Y.keyCode.HOME && !e.shiftKey || s === Y.keyCode.PAGE_UP ? (e.preventDefault(), I(r, 0, e.shiftKey ? l.begin : 0, !0)) : (G.undoOnEscape && s === Y.keyCode.ESCAPE || 90 === s && e.ctrlKey) && !0 !== e.altKey ? (D(r, !0, !1, L.split("")), o.trigger("click")) : s !== Y.keyCode.INSERT || e.shiftKey || e.ctrlKey ? !0 === G.tabThrough && s === Y.keyCode.TAB ? (!0 === e.shiftKey ? (null === g(l.begin).match.fn && (l.begin = R(l.begin)), l.end = v(l.begin, !0), l.begin = v(l.end, !0)) : (l.begin = R(l.begin, !0), l.end = R(l.begin, !0), l.end < F.maskLength && l.end--), l.begin < F.maskLength && (e.preventDefault(), I(r, l.begin, l.end))) : e.shiftKey || !1 === G.insertMode && (s === Y.keyCode.RIGHT ? setTimeout(function () { var e = I(r); I(r, e.begin) }, 0) : s === Y.keyCode.LEFT && setTimeout(function () { var e = I(r); I(r, H ? e.begin + 1 : e.begin - 1) }, 0)) : (G.insertMode = !G.insertMode, I(r, G.insertMode || l.begin !== F.maskLength ? l.begin : l.begin - 1)), G.onKeyDown.call(this, e, E(), I(r).begin, G), W = -1 !== q.inArray(s, G.ignorables) }, keypressEvent: function (e, t, a, n, i) { var r = this, o = q(r), s = e.which || e.charCode || e.keyCode; if (!(!0 === t || e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || W)) return s === Y.keyCode.ENTER && L !== E().join("") && (L = E().join(""), setTimeout(function () { o.trigger("change") }, 0)), !0; if (s) { 46 === s && !1 === e.shiftKey && "" !== G.radixPoint && (s = G.radixPoint.charCodeAt(0)); var l, c = t ? { begin: i, end: i } : I(r), u = String.fromCharCode(s); F.writeOutBuffer = !0; var p, f = O(c, u, n); if (!1 !== f && (w(!0), l = f.caret !== J ? f.caret : t ? f.pos + 1 : R(f.pos), F.p = l), !1 !== a && (setTimeout(function () { G.onKeyValidation.call(r, s, f, G) }, 0), F.writeOutBuffer && !1 !== f) && (p = E(), P(r, p, G.numericInput && f.caret === J ? v(l) : l, e, !0 !== t), !0 !== t && setTimeout(function () { !0 === N(p) && o.trigger("complete") }, 0)), e.preventDefault(), t) return f.forwardPosition = l, f } }, pasteEvent: function (e) { var t, a = this, n = e.originalEvent || e, i = q(a), r = a.inputmask._valueGet(!0), o = I(a); H && (t = o.end, o.end = o.begin, o.begin = t); var s = r.substr(0, o.begin), l = r.substr(o.end, r.length); if (s === (H ? y().reverse() : y()).slice(0, o.begin).join("") && (s = ""), l === (H ? y().reverse() : y()).slice(o.end).join("") && (l = ""), H && (t = s, s = l, l = t), Z.clipboardData && Z.clipboardData.getData) r = s + Z.clipboardData.getData("Text") + l; else { if (!n.clipboardData || !n.clipboardData.getData) return !0; r = s + n.clipboardData.getData("text/plain") + l } var c = r; if (q.isFunction(G.onBeforePaste)) { if (!1 === (c = G.onBeforePaste(r, G))) return e.preventDefault(); c = c || r } return D(a, !1, !1, H ? c.split("").reverse() : c.toString().split("")), P(a, E(), R(A()), e, L !== E().join("")), !0 === N(E()) && i.trigger("complete"), e.preventDefault() }, inputFallBackEvent: function (e) { var t = this, a = t.inputmask._valueGet(); if (E().join("") !== a) { var n = I(t); if ("." === a.charAt(n.begin - 1) && "" !== G.radixPoint && ((a = a.split(""))[n.begin - 1] = G.radixPoint.charAt(0), a = a.join("")), a.charAt(n.begin - 1) === G.radixPoint && a.length > E().length) return (i = new q.Event("keypress")).which = G.radixPoint.charCodeAt(0), Q.keypressEvent.call(t, i, !0, !0, !1, n.begin), !1; if (a = a.replace(new RegExp("(" + Y.escapeRegex(y().join("")) + ")*"), ""), te) { var i, r = a.replace(E().join(""), ""); if (1 === r.length) return (i = new q.Event("keypress")).which = r.charCodeAt(0), Q.keypressEvent.call(t, i, !0, !0, !1, F.validPositions[n.begin - 1] ? n.begin : n.begin - 1), !1 } if (n.begin > a.length && (I(t, a.length), n = I(t)), E().length - a.length != 1 || a.charAt(n.begin) === E()[n.begin] || a.charAt(n.begin + 1) === E()[n.begin] || M(n.begin)) { var o = [], s = f(!0, 1).join(""); for (o.push(a.substr(0, n.begin)), o.push(a.substr(n.begin)); null === a.match(Y.escapeRegex(s) + "$");)s = s.slice(1); a = a.replace(s, ""), q.isFunction(G.onBeforeMask) && (a = G.onBeforeMask(a, G) || a), D(t, !0, !1, a.split(""), e); var l = I(t).begin, c = t.inputmask._valueGet(), u = c.indexOf(o[0]); if (0 === u && l !== o[0].length) I(t, o[0].length), ne && setTimeout(function () { I(t, o[0].length) }, 0); else { for (; null === c.match(Y.escapeRegex(o[1]) + "$");)o[1] = o[1].substr(1); var p = c.indexOf(o[1]); -1 !== p && "" !== o[1] && p < l && u < p && (I(t, p), ne && setTimeout(function () { I(t, p) }, 0)) } !0 === N(E()) && q(t).trigger("complete") } else e.keyCode = Y.keyCode.BACKSPACE, Q.keydownEvent.call(t, e); e.preventDefault() } }, setValueEvent: function (e) { this.inputmask.refreshValue = !1; var t = this.inputmask._valueGet(!0); q.isFunction(G.onBeforeMask) && (t = G.onBeforeMask(t, G) || t), t = t.split(""), D(this, !0, !1, H ? t.reverse() : t), L = E().join(""), (G.clearMaskOnLostFocus || G.clearIncomplete) && this.inputmask._valueGet() === y().join("") && this.inputmask._valueSet("") }, focusEvent: function (e) { var t = this, a = t.inputmask._valueGet(); G.showMaskOnFocus && (!G.showMaskOnHover || G.showMaskOnHover && "" === a) && (t.inputmask._valueGet() !== E().join("") ? P(t, E(), R(A())) : !1 === n && I(t, R(A()))), !0 === G.positionCaretOnTab && !1 === n && (P(t, E(), I(t)), Q.clickEvent.apply(t, [e, !0])), L = E().join("") }, mouseleaveEvent: function (e) { var t, a; n = !1, G.clearMaskOnLostFocus && X.activeElement !== this && (t = E().slice(), (a = this.inputmask._valueGet()) !== this.getAttribute("placeholder") && "" !== a && (-1 === A() && a === y().join("") ? t = [] : j(t), P(this, t))) }, clickEvent: function (e, r) { var o = this; setTimeout(function () { if (X.activeElement === o) { var e = I(o); if (r && (H ? e.end = e.begin : e.begin = e.end), e.begin === e.end) switch (G.positionCaretOnClick) { case "none": break; case "radixFocus": if (function (e) { if ("" !== G.radixPoint) { var t = F.validPositions; if (t[e] === J || t[e].input === _(e)) { if (e < R(-1)) return 1; var a = q.inArray(G.radixPoint, E()); if (-1 !== a) { for (var n in t) if (a < n && t[n].input !== _(n)) return; return 1 } } } }(e.begin)) { var t = E().join("").indexOf(G.radixPoint); I(o, G.numericInput ? R(t) : t); break } default: var a, n = e.begin, i = R(A(n, !0)); n < i ? I(o, M(n) || M(n - 1) ? n : R(n)) : (("" !== (a = _(i)) && E()[i] !== a && !0 !== g(i).match.optionalQuantifier || !M(i) && g(i).match.def === a) && (i = R(i)), I(o, i)) } } }, 0) }, dblclickEvent: function (e) { var t = this; setTimeout(function () { I(t, 0, R(A())) }, 0) }, cutEvent: function (e) { var t = this, a = q(t), n = I(t), i = e.originalEvent || e, r = Z.clipboardData || i.clipboardData, o = H ? E().slice(n.end, n.begin) : E().slice(n.begin, n.end); r.setData("text", H ? o.reverse().join("") : o.join("")), X.execCommand && X.execCommand("copy"), T(t, Y.keyCode.DELETE, n), P(t, E(), F.p, e, L !== E().join("")), t.inputmask._valueGet() === y().join("") && a.trigger("cleared") }, blurEvent: function (e) { var t, a, n = q(this); this.inputmask && (t = this.inputmask._valueGet(), a = E().slice(), "" !== t && (G.clearMaskOnLostFocus && (-1 === A() && t === y().join("") ? a = [] : j(a)), !1 === N(a) && (setTimeout(function () { n.trigger("incomplete") }, 0), G.clearIncomplete && (w(), a = G.clearMaskOnLostFocus ? [] : y().slice())), P(this, a, J, e)), L !== E().join("") && (L = a.join(""), n.trigger("change"))) }, mouseenterEvent: function (e) { n = !0, X.activeElement !== this && G.showMaskOnHover && this.inputmask._valueGet() !== E().join("") && P(this, E()) }, submitEvent: function (e) { L !== E().join("") && V.trigger("change"), G.clearMaskOnLostFocus && -1 === A() && U.inputmask._valueGet && U.inputmask._valueGet() === y().join("") && U.inputmask._valueSet(""), G.removeMaskOnSubmit && (U.inputmask._valueSet(U.inputmask.unmaskedvalue(), !0), setTimeout(function () { P(U, E()) }, 0)) }, resetEvent: function (e) { U.inputmask.refreshValue = !0, setTimeout(function () { V.trigger("setvalue") }, 0) } }; if (e !== J) switch (e.action) { case "isComplete": return U = e.el, N(E()); case "unmaskedvalue": return U !== J && e.value === J || (a = e.value, a = (q.isFunction(G.onBeforeMask) && G.onBeforeMask(a, G) || a).split(""), D(J, !1, !1, H ? a.reverse() : a), q.isFunction(G.onBeforeWrite) && G.onBeforeWrite(J, E(), 0, G)), t(U); case "mask": !function (e) { z.off(e); var t, a, n, i, r, o, s, l, c, u, p, f, d, m, h = (a = G, p = (t = e).getAttribute("type"), (f = "INPUT" === t.tagName && -1 !== q.inArray(p, a.supportsInputType) || t.isContentEditable || "TEXTAREA" === t.tagName) || ("INPUT" === t.tagName ? ((n = X.createElement("input")).setAttribute("type", p), f = "text" === n.type, n = null) : f = "partial"), !1 !== f && ((i = t).inputmask.__valueGet || (!0 !== a.noValuePatching && (Object.getOwnPropertyDescriptor ? ("function" != typeof Object.getPrototypeOf && (Object.getPrototypeOf = "object" == typeof "test".__proto__ ? function (e) { return e.__proto__ } : function (e) { return e.constructor.prototype }), (s = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(i), "value") : J) && s.get && s.set ? (r = s.get, o = s.set, Object.defineProperty(i, "value", { get: g, set: v, configurable: !0 })) : "INPUT" !== i.tagName && (r = function () { return this.textContent }, o = function (e) { this.textContent = e }, Object.defineProperty(i, "value", { get: g, set: v, configurable: !0 }))) : X.__lookupGetter__ && i.__lookupGetter__("value") && (r = i.__lookupGetter__("value"), o = i.__lookupSetter__("value"), i.__defineGetter__("value", g), i.__defineSetter__("value", v)), i.inputmask.__valueGet = r, i.inputmask.__valueSet = o), i.inputmask._valueGet = function (e) { return H && !0 !== e ? r.call(this.el).split("").reverse().join("") : r.call(this.el) }, i.inputmask._valueSet = function (e, t) { o.call(this.el, null === e || e === J ? "" : !0 !== t && H ? e.split("").reverse().join("") : e) }, r === J && (r = function () { return this.value }, o = function (e) { this.value = e }, l = i.type, !q.valHooks || q.valHooks[l] !== J && !0 === q.valHooks[l].inputmaskpatch || (c = q.valHooks[l] && q.valHooks[l].get ? q.valHooks[l].get : function (e) { return e.value }, u = q.valHooks[l] && q.valHooks[l].set ? q.valHooks[l].set : function (e, t) { return e.value = t, e }, q.valHooks[l] = { get: function (e) { if (e.inputmask) { if (e.inputmask.opts.autoUnmask) return e.inputmask.unmaskedvalue(); var t = c(e); return -1 !== A(J, J, e.inputmask.maskset.validPositions) || !0 !== a.nullable ? t : "" } return c(e) }, set: function (e, t) { var a = q(e), n = u(e, t); return e.inputmask && a.trigger("setvalue"), n }, inputmaskpatch: !0 }), z.on(i, "mouseenter", function (e) { var t = q(this); this.inputmask._valueGet() !== E().join("") && t.trigger("setvalue") })))), f); function g() { return this.inputmask ? this.inputmask.opts.autoUnmask ? this.inputmask.unmaskedvalue() : -1 !== A() || !0 !== a.nullable ? X.activeElement === this && a.clearMaskOnLostFocus ? (H ? j(E().slice()).reverse() : j(E().slice())).join("") : r.call(this) : "" : r.call(this) } function v(e) { o.call(this, e), this.inputmask && q(this).trigger("setvalue") } !1 !== h && (V = q(U = e), !0 === G.colorMask && B(U), ne && (U.hasOwnProperty("inputmode") && (U.inputmode = G.inputmode, U.setAttribute("inputmode", G.inputmode)), "rtfm" === G.androidHack && (!0 !== G.colorMask && B(U), U.type = "password")), !0 === h && (z.on(U, "submit", Q.submitEvent), z.on(U, "reset", Q.resetEvent), z.on(U, "mouseenter", Q.mouseenterEvent), z.on(U, "blur", Q.blurEvent), z.on(U, "focus", Q.focusEvent), z.on(U, "mouseleave", Q.mouseleaveEvent), !0 !== G.colorMask && z.on(U, "click", Q.clickEvent), z.on(U, "dblclick", Q.dblclickEvent), z.on(U, "paste", Q.pasteEvent), z.on(U, "dragdrop", Q.pasteEvent), z.on(U, "drop", Q.pasteEvent), z.on(U, "cut", Q.cutEvent), z.on(U, "complete", G.oncomplete), z.on(U, "incomplete", G.onincomplete), z.on(U, "cleared", G.oncleared), ne || !0 === G.inputEventOnly || (z.on(U, "keydown", Q.keydownEvent), z.on(U, "keypress", Q.keypressEvent)), z.on(U, "compositionstart", q.noop), z.on(U, "compositionupdate", q.noop), z.on(U, "compositionend", q.noop), z.on(U, "keyup", q.noop), z.on(U, "input", Q.inputFallBackEvent), z.on(U, "beforeinput", q.noop)), z.on(U, "setvalue", Q.setValueEvent), L = y().join(""), "" !== U.inputmask._valueGet(!0) || !1 === G.clearMaskOnLostFocus || X.activeElement === U) && ("" !== (d = q.isFunction(G.onBeforeMask) && G.onBeforeMask(U.inputmask._valueGet(!0), G) || U.inputmask._valueGet(!0)) && D(U, !0, !1, H ? d.split("").reverse() : d.split("")), !1 === N(m = E().slice()) && G.clearIncomplete && w(), G.clearMaskOnLostFocus && X.activeElement !== U && (-1 === A() ? m = [] : j(m)), P(U, m), X.activeElement === U && I(U, R(A()))) }(U); break; case "format": return a = (q.isFunction(G.onBeforeMask) && G.onBeforeMask(e.value, G) || e.value).split(""), D(J, !0, !1, H ? a.reverse() : a), e.metadata ? { value: H ? E().slice().reverse().join("") : E().join(""), metadata: $.call(this, { action: "getmetadata" }, F, G) } : H ? E().slice().reverse().join("") : E().join(""); case "isValid": e.value ? (a = e.value.split(""), D(J, !0, !0, H ? a.reverse() : a)) : e.value = E().join(""); for (var i = E(), r = o(), c = i.length - 1; r < c && !M(c); c--); return i.splice(r, c + 1 - r), N(i) && e.value === E().join(""); case "getemptymask": return y().join(""); case "remove": return U && U.inputmask && (V = q(U), U.inputmask._valueSet(G.autoUnmask ? t(U) : U.inputmask._valueGet(!0)), z.off(U), Object.getOwnPropertyDescriptor && Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(U), "value") && U.inputmask.__valueGet && Object.defineProperty(U, "value", { get: U.inputmask.__valueGet, set: U.inputmask.__valueSet, configurable: !0 }) : X.__lookupGetter__ && U.__lookupGetter__("value") && U.inputmask.__valueGet && (U.__defineGetter__("value", U.inputmask.__valueGet), U.__defineSetter__("value", U.inputmask.__valueSet)), U.inputmask = J), U; case "getmetadata": if (q.isArray(F.metadata)) { var u = f(!0, 0, !1).join(""); return q.each(F.metadata, function (e, t) { if (t.mask === u) return u = t, !1 }), u } return F.metadata } } var q, Z, X, J, e, ee, te, ae, ne; window.Inputmask = (q = window.dependencyLib || jQuery, Z = window, X = document, e = navigator.userAgent, ee = /mobile/i.test(e), te = /iemobile/i.test(e), ae = /iphone/i.test(e) && !te, ne = /android/i.test(e) && !te, Y.prototype = { dataAttribute: "data-inputmask", defaults: { placeholder: "_", optionalmarker: { start: "[", end: "]" }, quantifiermarker: { start: "{", end: "}" }, groupmarker: { start: "(", end: ")" }, alternatormarker: "|", escapeChar: "\\", mask: null, regex: null, oncomplete: q.noop, onincomplete: q.noop, oncleared: q.noop, repeat: 0, greedy: !0, autoUnmask: !1, removeMaskOnSubmit: !1, clearMaskOnLostFocus: !0, insertMode: !0, clearIncomplete: !1, alias: null, onKeyDown: q.noop, onBeforeMask: null, onBeforePaste: function (e, t) { return q.isFunction(t.onBeforeMask) ? t.onBeforeMask(e, t) : e }, onBeforeWrite: null, onUnMask: null, showMaskOnFocus: !0, showMaskOnHover: !0, onKeyValidation: q.noop, skipOptionalPartCharacter: " ", numericInput: !1, rightAlign: !1, undoOnEscape: !0, radixPoint: "", radixPointDefinitionSymbol: J, groupSeparator: "", keepStatic: null, positionCaretOnTab: !0, tabThrough: !1, supportsInputType: ["text", "tel", "password"], ignorables: [8, 9, 13, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 0, 229], isComplete: null, canClearPosition: q.noop, preValidation: null, postValidation: null, staticDefinitionSymbol: J, jitMasking: !1, nullable: !0, inputEventOnly: !1, noValuePatching: !1, positionCaretOnClick: "lvp", casing: null, inputmode: "verbatim", colorMask: !1, androidHack: !1 }, definitions: { 9: { validator: "[0-9]", cardinality: 1, definitionSymbol: "*" }, a: { validator: "[A-Za-zА-яЁёÀ-ÿµ]", cardinality: 1, definitionSymbol: "*" }, "*": { validator: function () { return !0 }, cardinality: 1 } }, aliases: {}, masksCache: {}, mask: function (e) { var i = this; return "string" == typeof e && (e = X.getElementById(e) || X.querySelectorAll(e)), e = e.nodeName ? [e] : e, q.each(e, function (e, t) { var a = q.extend(!0, {}, i.opts); !function (a, e, n, i) { function t(e, t) { null !== (t = t !== J ? t : a.getAttribute(i + "-" + e)) && ("string" == typeof t && (0 === e.indexOf("on") ? t = Z[t] : "false" === t ? t = !1 : "true" === t && (t = !0)), n[e] = t) } "rtl" !== a.dir && !e.rightAlign || (a.style.textAlign = "right"), "rtl" !== a.dir && !e.numericInput || (a.dir = "ltr", a.removeAttribute("dir"), e.isRTL = !0); var r, o, s, l, c = a.getAttribute(i); if (c && "" !== c && (c = c.replace(new RegExp("'", "g"), '"'), o = JSON.parse("{" + c + "}")), o) for (l in s = J, o) if ("alias" === l.toLowerCase()) { s = o[l]; break } for (r in t("alias", s), n.alias && u(n.alias, n, e), e) { if (o) for (l in s = J, o) if (l.toLowerCase() === r.toLowerCase()) { s = o[l]; break } t(r, s) } q.extend(!0, e, n) }(t, a, q.extend(!0, {}, i.userOptions), i.dataAttribute); var n = r(a, i.noMasksCache); n !== J && (t.inputmask !== J && t.inputmask.remove(), t.inputmask = new Y(J, J, !0), t.inputmask.opts = a, t.inputmask.noMasksCache = i.noMasksCache, t.inputmask.userOptions = q.extend(!0, {}, i.userOptions), t.inputmask.isRTL = a.isRTL, (t.inputmask.el = t).inputmask.maskset = n, q.data(t, "_inputmask_opts", a), $.call(t.inputmask, { action: "mask" })) }), e && e[0] && e[0].inputmask || this }, option: function (e, t) { return "string" == typeof e ? this.opts[e] : "object" == typeof e ? (q.extend(this.userOptions, e), this.el && !0 !== t && this.mask(this.el), this) : void 0 }, unmaskedvalue: function (e) { return this.maskset = this.maskset || r(this.opts, this.noMasksCache), $.call(this, { action: "unmaskedvalue", value: e }) }, remove: function () { return $.call(this, { action: "remove" }) }, getemptymask: function () { return this.maskset = this.maskset || r(this.opts, this.noMasksCache), $.call(this, { action: "getemptymask" }) }, hasMaskedValue: function () { return !this.opts.autoUnmask }, isComplete: function () { return this.maskset = this.maskset || r(this.opts, this.noMasksCache), $.call(this, { action: "isComplete" }) }, getmetadata: function () { return this.maskset = this.maskset || r(this.opts, this.noMasksCache), $.call(this, { action: "getmetadata" }) }, isValid: function (e) { return this.maskset = this.maskset || r(this.opts, this.noMasksCache), $.call(this, { action: "isValid", value: e }) }, format: function (e, t) { return this.maskset = this.maskset || r(this.opts, this.noMasksCache), $.call(this, { action: "format", value: e, metadata: t }) }, analyseMask: function (e, p, f) { function t(e, t, a, n) { this.matches = [], this.openGroup = e || !1, this.alternatorGroup = !1, this.isGroup = e || !1, this.isOptional = t || !1, this.isQuantifier = a || !1, this.isAlternator = n || !1, this.quantifier = { min: 1, max: 1 } } function r(a, e, n) { n = n !== J ? n : a.matches.length; var i = a.matches[n - 1]; if (p) 0 === e.indexOf("[") || h ? a.matches.splice(n++, 0, { fn: new RegExp(e, f.casing ? "i" : ""), cardinality: 1, optionality: a.isOptional, newBlockMarker: i === J || i.def !== e, casing: null, def: e, placeholder: J, nativeDef: e }) : q.each(e.split(""), function (e, t) { i = a.matches[n - 1], a.matches.splice(n++, 0, { fn: null, cardinality: 0, optionality: a.isOptional, newBlockMarker: i === J || i.def !== t && null !== i.fn, casing: null, def: f.staticDefinitionSymbol || t, placeholder: f.staticDefinitionSymbol !== J ? t : J, nativeDef: t }) }), h = !1; else { var t = (f.definitions ? f.definitions[e] : J) || Y.prototype.definitions[e]; if (t && !h) { for (var r = t.prevalidator, o = r ? r.length : 0, s = 1; s < t.cardinality; s++) { var l = s <= o ? r[s - 1] : [], c = l.validator, u = l.cardinality; a.matches.splice(n++, 0, { fn: c ? "string" == typeof c ? new RegExp(c, f.casing ? "i" : "") : new function () { this.test = c } : new RegExp("."), cardinality: u || 1, optionality: a.isOptional, newBlockMarker: i === J || i.def !== (t.definitionSymbol || e), casing: t.casing, def: t.definitionSymbol || e, placeholder: t.placeholder, nativeDef: e }), i = a.matches[n - 1] } a.matches.splice(n++, 0, { fn: t.validator ? "string" == typeof t.validator ? new RegExp(t.validator, f.casing ? "i" : "") : new function () { this.test = t.validator } : new RegExp("."), cardinality: t.cardinality, optionality: a.isOptional, newBlockMarker: i === J || i.def !== (t.definitionSymbol || e), casing: t.casing, def: t.definitionSymbol || e, placeholder: t.placeholder, nativeDef: e }) } else a.matches.splice(n++, 0, { fn: null, cardinality: 0, optionality: a.isOptional, newBlockMarker: i === J || i.def !== e && null !== i.fn, casing: null, def: f.staticDefinitionSymbol || e, placeholder: f.staticDefinitionSymbol !== J ? e : J, nativeDef: e }), h = !1 } } function a() { if (0 < v.length) { if (r(i = v[v.length - 1], x), i.isAlternator) { o = v.pop(); for (var e = 0; e < o.matches.length; e++)o.matches[e].isGroup = !1; 0 < v.length ? (i = v[v.length - 1]).matches.push(o) : g.matches.push(o) } } else r(g, x) } var n, i, o, s, l, c, u, d = /(?:[?*+]|\{[0-9\+\*]+(?:,[0-9\+\*]*)?\})|[^.?*+^${[]()|\\]+|./g, m = /\[\^?]?(?:[^\\\]]+|\\[\S\s]?)*]?|\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)|\((?:\?[:=!]?)?|(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[()|\\]+|./g, h = !1, g = new t, v = [], y = []; for (p && (f.optionalmarker.start = J, f.optionalmarker.end = J); P = p ? m.exec(e) : d.exec(e);) { if (x = P[0], p) switch (x.charAt(0)) { case "?": x = "{0,1}"; break; case "+": case "*": x = "{" + x + "}" }if (h) a(); else switch (x.charAt(0)) { case f.escapeChar: h = !0, p && a(); break; case f.optionalmarker.end: case f.groupmarker.end: if ((n = v.pop()).openGroup = !1, n !== J) if (0 < v.length) { if ((i = v[v.length - 1]).matches.push(n), i.isAlternator) { o = v.pop(); for (var k = 0; k < o.matches.length; k++)o.matches[k].isGroup = !1, o.matches[k].alternatorGroup = !1; 0 < v.length ? (i = v[v.length - 1]).matches.push(o) : g.matches.push(o) } } else g.matches.push(n); else a(); break; case f.optionalmarker.start: v.push(new t(!1, !0)); break; case f.groupmarker.start: v.push(new t(!0)); break; case f.quantifiermarker.start: var x, b, P, w = new t(!1, !1, !0), A = (x = x.replace(/[{}]/g, "")).split(","), S = isNaN(A[0]) ? A[0] : parseInt(A[0]), E = 1 === A.length ? S : isNaN(A[1]) ? A[1] : parseInt(A[1]); "*" !== E && "+" !== E || (S = "*" === E ? 0 : 1), w.quantifier = { min: S, max: E }, 0 < v.length ? ((P = (b = v[v.length - 1].matches).pop()).isGroup || ((s = new t(!0)).matches.push(P), P = s), b.push(P), b.push(w)) : ((P = g.matches.pop()).isGroup || ((s = new t(!0)).matches.push(P), P = s), g.matches.push(P), g.matches.push(w)); break; case f.alternatormarker: (c = 0 < v.length ? (l = (i = v[v.length - 1]).matches[i.matches.length - 1], i.openGroup && (l.matches === J || !1 === l.isGroup && !1 === l.isAlternator) ? v.pop() : i.matches.pop()) : g.matches.pop()).isAlternator ? v.push(c) : (c.alternatorGroup ? (o = v.pop(), c.alternatorGroup = !1) : o = new t(!1, !1, !1, !0), o.matches.push(c), v.push(o), c.openGroup && ((u = new t(!(c.openGroup = !1))).alternatorGroup = !0, v.push(u))); break; default: a() } } for (; 0 < v.length;)n = v.pop(), g.matches.push(n); return 0 < g.matches.length && (function n(i) { i && i.matches && q.each(i.matches, function (e, t) { var a = i.matches[e + 1]; (a === J || a.matches === J || !1 === a.isQuantifier) && t && t.isGroup && (t.isGroup = !1, p || (r(t, f.groupmarker.start, 0), !0 !== t.openGroup && r(t, f.groupmarker.end))), n(t) }) }(g), y.push(g)), (f.numericInput || f.isRTL) && function e(t) { for (var a in t.matches = t.matches.reverse(), t.matches) { var n, i; t.matches.hasOwnProperty(a) && (n = parseInt(a), t.matches[a].isQuantifier && t.matches[n + 1] && t.matches[n + 1].isGroup && (i = t.matches[a], t.matches.splice(a, 1), t.matches.splice(n + 1, 0, i)), t.matches[a].matches !== J ? t.matches[a] = e(t.matches[a]) : t.matches[a] = ((r = t.matches[a]) === f.optionalmarker.start ? r = f.optionalmarker.end : r === f.optionalmarker.end ? r = f.optionalmarker.start : r === f.groupmarker.start ? r = f.groupmarker.end : r === f.groupmarker.end && (r = f.groupmarker.start), r)) } var r; return t }(y[0]), y } }, Y.extendDefaults = function (e) { q.extend(!0, Y.prototype.defaults, e) }, Y.extendDefinitions = function (e) { q.extend(!0, Y.prototype.definitions, e) }, Y.extendAliases = function (e) { q.extend(!0, Y.prototype.aliases, e) }, Y.format = function (e, t, a) { return Y(t).format(e, a) }, Y.unmask = function (e, t) { return Y(t).unmaskedvalue(e) }, Y.isValid = function (e, t) { return Y(t).isValid(e) }, Y.remove = function (e) { q.each(e, function (e, t) { t.inputmask && t.inputmask.remove() }) }, Y.escapeRegex = function (e) { return e.replace(new RegExp("(\\" + ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^"].join("|\\") + ")", "gim"), "\\$1") }, Y.keyCode = { ALT: 18, BACKSPACE: 8, BACKSPACE_SAFARI: 127, CAPS_LOCK: 20, COMMA: 188, COMMAND: 91, COMMAND_LEFT: 91, COMMAND_RIGHT: 93, CONTROL: 17, DELETE: 46, DOWN: 40, END: 35, ENTER: 13, ESCAPE: 27, HOME: 36, INSERT: 45, LEFT: 37, MENU: 93, NUMPAD_ADD: 107, NUMPAD_DECIMAL: 110, NUMPAD_DIVIDE: 111, NUMPAD_ENTER: 108, NUMPAD_MULTIPLY: 106, NUMPAD_SUBTRACT: 109, PAGE_DOWN: 34, PAGE_UP: 33, PERIOD: 190, RIGHT: 39, SHIFT: 16, SPACE: 32, TAB: 9, UP: 38, WINDOWS: 91, X: 88 }, Y) }(), function () { var i, r; i = jQuery, r = window.Inputmask, void 0 === i.fn.inputmask && (i.fn.inputmask = function (e, t) { var a, n = this[0]; if (void 0 === t && (t = {}), "string" == typeof e) switch (e) { case "unmaskedvalue": return n && n.inputmask ? n.inputmask.unmaskedvalue() : i(n).val(); case "remove": return this.each(function () { this.inputmask && this.inputmask.remove() }); case "getemptymask": return n && n.inputmask ? n.inputmask.getemptymask() : ""; case "hasMaskedValue": return !(!n || !n.inputmask) && n.inputmask.hasMaskedValue(); case "isComplete": return !n || !n.inputmask || n.inputmask.isComplete(); case "getmetadata": return n && n.inputmask ? n.inputmask.getmetadata() : void 0; case "setvalue": i(n).val(t), n && void 0 === n.inputmask && i(n).triggerHandler("setvalue"); break; case "option": if ("string" != typeof t) return this.each(function () { if (void 0 !== this.inputmask) return this.inputmask.option(t) }); if (n && void 0 !== n.inputmask) return n.inputmask.option(t); break; default: return t.alias = e, a = new r(t), this.each(function () { a.mask(this) }) } else { if ("object" == typeof e) return a = new r(e), void 0 === e.mask && void 0 === e.alias ? this.each(function () { if (void 0 !== this.inputmask) return this.inputmask.option(e); a.mask(this) }) : this.each(function () { a.mask(this) }); if (void 0 === e) return this.each(function () { (a = new r(t)).mask(this) }) } }), i.fn.inputmask }(), function () { var o, s; o = window.dependencyLib || jQuery, (s = window.Inputmask).extendAliases({ "dd/mm/yyyy": { mask: "1/2/y", placeholder: "dd/mm/yyyy", regex: { val1pre: new RegExp("[0-3]"), val1: new RegExp("0[1-9]|[12][0-9]|3[01]"), val2pre: function (e) { var t = s.escapeRegex.call(this, e); return new RegExp("((0[1-9]|[12][0-9]|3[01])" + t + "[01])") }, val2: function (e) { var t = s.escapeRegex.call(this, e); return new RegExp("((0[1-9]|[12][0-9])" + t + "(0[1-9]|1[012]))|(30" + t + "(0[13-9]|1[012]))|(31" + t + "(0[13578]|1[02]))") } }, leapday: "29/02/", separator: "/", yearrange: { minyear: 1900, maxyear: 2099 }, isInYearRange: function (e, t, a) { if (isNaN(e)) return !1; var n = parseInt(e.concat(t.toString().slice(e.length))), i = parseInt(e.concat(a.toString().slice(e.length))); return !isNaN(n) && t <= n && n <= a || !isNaN(i) && t <= i && i <= a }, determinebaseyear: function (e, t, a) { var n = (new Date).getFullYear(); if (n < e) return e; if (t < n) { for (var i = t.toString().slice(0, 2), r = t.toString().slice(2, 4); t < i + a;)i--; var o = i + r; return o < e ? e : o } if (e <= n && n <= t) { for (var s = n.toString().slice(0, 2); t < s + a;)s--; var l = s + a; return l < e ? e : l } return n }, onKeyDown: function (e, t, a, n) { var i, r = o(this); e.ctrlKey && e.keyCode === s.keyCode.RIGHT && (i = new Date, r.val(i.getDate().toString() + (i.getMonth() + 1).toString() + i.getFullYear().toString()), r.trigger("setvalue")) }, getFrontValue: function (e, t, a) { for (var n = 0, i = 0, r = 0; r < e.length && "2" !== e.charAt(r); r++) { var o = a.definitions[e.charAt(r)]; o ? (n += i, i = o.cardinality) : i++ } return t.join("").substr(n, i) }, postValidation: function (e, t, a) { var n, i, r = e.join(""), o = 0 === a.mask.indexOf("y") ? (n = r.substr(0, 4), r.substring(4, 10)) : (n = r.substring(6, 10), r.substr(0, 6)); return t && (o !== a.leapday || (i = n, isNaN(i) || 29 === new Date(i, 2, 0).getDate())) }, definitions: { 1: { validator: function (e, t, a, n, i) { var r = i.regex.val1.test(e); return n || r || e.charAt(1) !== i.separator && -1 === "-./".indexOf(e.charAt(1)) || !(r = i.regex.val1.test("0" + e.charAt(0))) ? r : (t.buffer[a - 1] = "0", { refreshFromBuffer: { start: a - 1, end: a }, pos: a, c: e.charAt(0) }) }, cardinality: 2, prevalidator: [{ validator: function (e, t, a, n, i) { var r = e; isNaN(t.buffer[a + 1]) || (r += t.buffer[a + 1]); var o = 1 === r.length ? i.regex.val1pre.test(r) : i.regex.val1.test(r); if (!n && !o) { if (o = i.regex.val1.test(e + "0")) return t.buffer[a] = e, t.buffer[++a] = "0", { pos: a, c: "0" }; if (o = i.regex.val1.test("0" + e)) return t.buffer[a] = "0", { pos: ++a } } return o }, cardinality: 1 }] }, 2: { validator: function (e, t, a, n, i) { var r = i.getFrontValue(t.mask, t.buffer, i); -1 !== r.indexOf(i.placeholder[0]) && (r = "01" + i.separator); var o = i.regex.val2(i.separator).test(r + e); return n || o || e.charAt(1) !== i.separator && -1 === "-./".indexOf(e.charAt(1)) || !(o = i.regex.val2(i.separator).test(r + "0" + e.charAt(0))) ? o : (t.buffer[a - 1] = "0", { refreshFromBuffer: { start: a - 1, end: a }, pos: a, c: e.charAt(0) }) }, cardinality: 2, prevalidator: [{ validator: function (e, t, a, n, i) { isNaN(t.buffer[a + 1]) || (e += t.buffer[a + 1]); var r = i.getFrontValue(t.mask, t.buffer, i); -1 !== r.indexOf(i.placeholder[0]) && (r = "01" + i.separator); var o = 1 === e.length ? i.regex.val2pre(i.separator).test(r + e) : i.regex.val2(i.separator).test(r + e); return n || o || !(o = i.regex.val2(i.separator).test(r + "0" + e)) ? o : (t.buffer[a] = "0", { pos: ++a }) }, cardinality: 1 }] }, y: { validator: function (e, t, a, n, i) { return i.isInYearRange(e, i.yearrange.minyear, i.yearrange.maxyear) }, cardinality: 4, prevalidator: [{ validator: function (e, t, a, n, i) { var r = i.isInYearRange(e, i.yearrange.minyear, i.yearrange.maxyear); if (!n && !r) { var o = i.determinebaseyear(i.yearrange.minyear, i.yearrange.maxyear, e + "0").toString().slice(0, 1); if (r = i.isInYearRange(o + e, i.yearrange.minyear, i.yearrange.maxyear)) return t.buffer[a++] = o.charAt(0), { pos: a }; if (o = i.determinebaseyear(i.yearrange.minyear, i.yearrange.maxyear, e + "0").toString().slice(0, 2), r = i.isInYearRange(o + e, i.yearrange.minyear, i.yearrange.maxyear)) return t.buffer[a++] = o.charAt(0), t.buffer[a++] = o.charAt(1), { pos: a } } return r }, cardinality: 1 }, { validator: function (e, t, a, n, i) { var r = i.isInYearRange(e, i.yearrange.minyear, i.yearrange.maxyear); if (!n && !r) { var o = i.determinebaseyear(i.yearrange.minyear, i.yearrange.maxyear, e).toString().slice(0, 2); if (r = i.isInYearRange(e[0] + o[1] + e[1], i.yearrange.minyear, i.yearrange.maxyear)) return t.buffer[a++] = o.charAt(1), { pos: a }; if (o = i.determinebaseyear(i.yearrange.minyear, i.yearrange.maxyear, e).toString().slice(0, 2), r = i.isInYearRange(o + e, i.yearrange.minyear, i.yearrange.maxyear)) return t.buffer[a - 1] = o.charAt(0), t.buffer[a++] = o.charAt(1), t.buffer[a++] = e.charAt(0), { refreshFromBuffer: { start: a - 3, end: a }, pos: a } } return r }, cardinality: 2 }, { validator: function (e, t, a, n, i) { return i.isInYearRange(e, i.yearrange.minyear, i.yearrange.maxyear) }, cardinality: 3 }] } }, insertMode: !1, autoUnmask: !1 }, "mm/dd/yyyy": { placeholder: "mm/dd/yyyy", alias: "dd/mm/yyyy", regex: { val2pre: function (e) { var t = s.escapeRegex.call(this, e); return new RegExp("((0[13-9]|1[012])" + t + "[0-3])|(02" + t + "[0-2])") }, val2: function (e) { var t = s.escapeRegex.call(this, e); return new RegExp("((0[1-9]|1[012])" + t + "(0[1-9]|[12][0-9]))|((0[13-9]|1[012])" + t + "30)|((0[13578]|1[02])" + t + "31)") }, val1pre: new RegExp("[01]"), val1: new RegExp("0[1-9]|1[012]") }, leapday: "02/29/", onKeyDown: function (e, t, a, n) { var i, r = o(this); e.ctrlKey && e.keyCode === s.keyCode.RIGHT && (i = new Date, r.val((i.getMonth() + 1).toString() + i.getDate().toString() + i.getFullYear().toString()), r.trigger("setvalue")) } }, "yyyy/mm/dd": { mask: "y/1/2", placeholder: "yyyy/mm/dd", alias: "mm/dd/yyyy", leapday: "/02/29", onKeyDown: function (e, t, a, n) { var i, r = o(this); e.ctrlKey && e.keyCode === s.keyCode.RIGHT && (i = new Date, r.val(i.getFullYear().toString() + (i.getMonth() + 1).toString() + i.getDate().toString()), r.trigger("setvalue")) } }, "dd.mm.yyyy": { mask: "1.2.y", placeholder: "dd.mm.yyyy", leapday: "29.02.", separator: ".", alias: "dd/mm/yyyy" }, "dd-mm-yyyy": { mask: "1-2-y", placeholder: "dd-mm-yyyy", leapday: "29-02-", separator: "-", alias: "dd/mm/yyyy" }, "mm.dd.yyyy": { mask: "1.2.y", placeholder: "mm.dd.yyyy", leapday: "02.29.", separator: ".", alias: "mm/dd/yyyy" }, "mm-dd-yyyy": { mask: "1-2-y", placeholder: "mm-dd-yyyy", leapday: "02-29-", separator: "-", alias: "mm/dd/yyyy" }, "yyyy.mm.dd": { mask: "y.1.2", placeholder: "yyyy.mm.dd", leapday: ".02.29", separator: ".", alias: "yyyy/mm/dd" }, "yyyy-mm-dd": { mask: "y-1-2", placeholder: "yyyy-mm-dd", leapday: "-02-29", separator: "-", alias: "yyyy/mm/dd" }, datetime: { mask: "1/2/y h:s", placeholder: "dd/mm/yyyy hh:mm", alias: "dd/mm/yyyy", regex: { hrspre: new RegExp("[012]"), hrs24: new RegExp("2[0-4]|1[3-9]"), hrs: new RegExp("[01][0-9]|2[0-4]"), ampm: new RegExp("^[a|p|A|P][m|M]"), mspre: new RegExp("[0-5]"), ms: new RegExp("[0-5][0-9]") }, timeseparator: ":", hourFormat: "24", definitions: { h: { validator: function (e, t, a, n, i) { if ("24" === i.hourFormat && 24 === parseInt(e, 10)) return t.buffer[a - 1] = "0", { refreshFromBuffer: { start: a - 1, end: a }, c: t.buffer[a] = "0" }; var r = i.regex.hrs.test(e); if (!n && !r && (e.charAt(1) === i.timeseparator || -1 !== "-.:".indexOf(e.charAt(1))) && (r = i.regex.hrs.test("0" + e.charAt(0)))) return t.buffer[a - 1] = "0", t.buffer[a] = e.charAt(0), { refreshFromBuffer: { start: ++a - 2, end: a }, pos: a, c: i.timeseparator }; if (r && "24" !== i.hourFormat && i.regex.hrs24.test(e)) { var o = parseInt(e, 10); return t.buffer[a + 5] = 24 === o ? "a" : "p", t.buffer[a + 6] = "m", (o -= 12) < 10 ? (t.buffer[a] = o.toString(), t.buffer[a - 1] = "0") : (t.buffer[a] = o.toString().charAt(1), t.buffer[a - 1] = o.toString().charAt(0)), { refreshFromBuffer: { start: a - 1, end: a + 6 }, c: t.buffer[a] } } return r }, cardinality: 2, prevalidator: [{ validator: function (e, t, a, n, i) { var r = i.regex.hrspre.test(e); return n || r || !(r = i.regex.hrs.test("0" + e)) ? r : (t.buffer[a] = "0", { pos: ++a }) }, cardinality: 1 }] }, s: { validator: "[0-5][0-9]", cardinality: 2, prevalidator: [{ validator: function (e, t, a, n, i) { var r = i.regex.mspre.test(e); return n || r || !(r = i.regex.ms.test("0" + e)) ? r : (t.buffer[a] = "0", { pos: ++a }) }, cardinality: 1 }] }, t: { validator: function (e, t, a, n, i) { return i.regex.ampm.test(e + "m") }, casing: "lower", cardinality: 1 } }, insertMode: !1, autoUnmask: !1 }, datetime12: { mask: "1/2/y h:s t\\m", placeholder: "dd/mm/yyyy hh:mm xm", alias: "datetime", hourFormat: "12" }, "mm/dd/yyyy hh:mm xm": { mask: "1/2/y h:s t\\m", placeholder: "mm/dd/yyyy hh:mm xm", alias: "datetime12", regex: { val2pre: function (e) { var t = s.escapeRegex.call(this, e); return new RegExp("((0[13-9]|1[012])" + t + "[0-3])|(02" + t + "[0-2])") }, val2: function (e) { var t = s.escapeRegex.call(this, e); return new RegExp("((0[1-9]|1[012])" + t + "(0[1-9]|[12][0-9]))|((0[13-9]|1[012])" + t + "30)|((0[13578]|1[02])" + t + "31)") }, val1pre: new RegExp("[01]"), val1: new RegExp("0[1-9]|1[012]") }, leapday: "02/29/", onKeyDown: function (e, t, a, n) { var i, r = o(this); e.ctrlKey && e.keyCode === s.keyCode.RIGHT && (i = new Date, r.val((i.getMonth() + 1).toString() + i.getDate().toString() + i.getFullYear().toString()), r.trigger("setvalue")) } }, "hh:mm t": { mask: "h:s t\\m", placeholder: "hh:mm xm", alias: "datetime", hourFormat: "12" }, "h:s t": { mask: "h:s t\\m", placeholder: "hh:mm xm", alias: "datetime", hourFormat: "12" }, "hh:mm:ss": { mask: "h:s:s", placeholder: "hh:mm:ss", alias: "datetime", autoUnmask: !1 }, "hh:mm": { mask: "h:s", placeholder: "hh:mm", alias: "datetime", autoUnmask: !1 }, date: { alias: "dd/mm/yyyy" }, "mm/yyyy": { mask: "1/y", placeholder: "mm/yyyy", leapday: "donotuse", separator: "/", alias: "mm/dd/yyyy" }, shamsi: { regex: { val2pre: function (e) { var t = s.escapeRegex.call(this, e); return new RegExp("((0[1-9]|1[012])" + t + "[0-3])") }, val2: function (e) { var t = s.escapeRegex.call(this, e); return new RegExp("((0[1-9]|1[012])" + t + "(0[1-9]|[12][0-9]))|((0[1-9]|1[012])" + t + "30)|((0[1-6])" + t + "31)") }, val1pre: new RegExp("[01]"), val1: new RegExp("0[1-9]|1[012]") }, yearrange: { minyear: 1300, maxyear: 1499 }, mask: "y/1/2", leapday: "/12/30", placeholder: "yyyy/mm/dd", alias: "mm/dd/yyyy", clearIncomplete: !0 }, "yyyy-mm-dd hh:mm:ss": { mask: "y-1-2 h:s:s", placeholder: "yyyy-mm-dd hh:mm:ss", alias: "datetime", separator: "-", leapday: "-02-29", regex: { val2pre: function (e) { var t = s.escapeRegex.call(this, e); return new RegExp("((0[13-9]|1[012])" + t + "[0-3])|(02" + t + "[0-2])") }, val2: function (e) { var t = s.escapeRegex.call(this, e); return new RegExp("((0[1-9]|1[012])" + t + "(0[1-9]|[12][0-9]))|((0[13-9]|1[012])" + t + "30)|((0[13578]|1[02])" + t + "31)") }, val1pre: new RegExp("[01]"), val1: new RegExp("0[1-9]|1[012]") }, onKeyDown: function (e, t, a, n) { } } }) }(), function () { var e; window.dependencyLib || jQuery, (e = window.Inputmask).extendDefinitions({ A: { validator: "[A-Za-zА-яЁёÀ-ÿµ]", cardinality: 1, casing: "upper" }, "&": { validator: "[0-9A-Za-zА-яЁёÀ-ÿµ]", cardinality: 1, casing: "upper" }, "#": { validator: "[0-9A-Fa-f]", cardinality: 1, casing: "upper" } }), e.extendAliases({ url: { definitions: { i: { validator: ".", cardinality: 1 } }, mask: "(\\http://)|(\\http\\s://)|(ftp://)|(ftp\\s://)i{+}", insertMode: !1, autoUnmask: !1, inputmode: "url" }, ip: { mask: "i[i[i]].i[i[i]].i[i[i]].i[i[i]]", definitions: { i: { validator: function (e, t, a, n, i) { return e = -1 < a - 1 && "." !== t.buffer[a - 1] ? (e = t.buffer[a - 1] + e, -1 < a - 2 && "." !== t.buffer[a - 2] ? t.buffer[a - 2] + e : "0" + e) : "00" + e, new RegExp("25[0-5]|2[0-4][0-9]|[01][0-9][0-9]").test(e) }, cardinality: 1 } }, onUnMask: function (e, t, a) { return e }, inputmode: "numeric" }, email: { mask: "*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]", greedy: !1, onBeforePaste: function (e, t) { return (e = e.toLowerCase()).replace("mailto:", "") }, definitions: { "*": { validator: "[0-9A-Za-z!#$%&'*+/=?^_`{|}~-]", cardinality: 1, casing: "lower" }, "-": { validator: "[0-9A-Za-z-]", cardinality: 1, casing: "lower" } }, onUnMask: function (e, t, a) { return e }, inputmode: "email" }, mac: { mask: "##:##:##:##:##:##" }, vin: { mask: "V{13}9{4}", definitions: { V: { validator: "[A-HJ-NPR-Za-hj-npr-z\\d]", cardinality: 1, casing: "upper" } }, clearIncomplete: !0, autoUnmask: !0 } }) }(), function () { function r(e, t) { for (var a = "", n = 0; n < e.length; n++)y.prototype.definitions[e.charAt(n)] || t.definitions[e.charAt(n)] || t.optionalmarker.start === e.charAt(n) || t.optionalmarker.end === e.charAt(n) || t.quantifiermarker.start === e.charAt(n) || t.quantifiermarker.end === e.charAt(n) || t.groupmarker.start === e.charAt(n) || t.groupmarker.end === e.charAt(n) || t.alternatormarker === e.charAt(n) ? a += "\\" + e.charAt(n) : a += e.charAt(n); return a } var v, y, k; v = window.dependencyLib || jQuery, (y = window.Inputmask).extendAliases({ numeric: { mask: function (e) { var t, a; 0 !== e.repeat && isNaN(e.integerDigits) && (e.integerDigits = e.repeat), e.repeat = 0, e.groupSeparator === e.radixPoint && ("." === e.radixPoint ? e.groupSeparator = "," : "," === e.radixPoint ? e.groupSeparator = "." : e.groupSeparator = ""), " " === e.groupSeparator && (e.skipOptionalPartCharacter = k), e.autoGroup = e.autoGroup && "" !== e.groupSeparator, e.autoGroup && ("string" == typeof e.groupSize && isFinite(e.groupSize) && (e.groupSize = parseInt(e.groupSize)), isFinite(e.integerDigits)) && (t = Math.floor(e.integerDigits / e.groupSize), a = e.integerDigits % e.groupSize, e.integerDigits = parseInt(e.integerDigits) + (0 == a ? t - 1 : t), e.integerDigits < 1 && (e.integerDigits = "*")), 1 < e.placeholder.length && (e.placeholder = e.placeholder.charAt(0)), "radixFocus" === e.positionCaretOnClick && "" === e.placeholder && !1 === e.integerOptional && (e.positionCaretOnClick = "lvp"), e.definitions[";"] = e.definitions["~"], e.definitions[";"].definitionSymbol = "~", !0 === e.numericInput && (e.positionCaretOnClick = "radixFocus" === e.positionCaretOnClick ? "lvp" : e.positionCaretOnClick, e.digitsOptional = !1, isNaN(e.digits) && (e.digits = 2), e.decimalProtect = !1); var n, i = "[+]"; return i += r(e.prefix, e), !0 === e.integerOptional ? i += "~{1," + e.integerDigits + "}" : i += "~{" + e.integerDigits + "}", e.digits !== k && (e.radixPointDefinitionSymbol = e.decimalProtect ? ":" : e.radixPoint, n = e.digits.toString().split(","), isFinite(n[0] && n[1] && isFinite(n[1])) ? i += e.radixPointDefinitionSymbol + ";{" + e.digits + "}" : (isNaN(e.digits) || 0 < parseInt(e.digits)) && (e.digitsOptional ? i += "[" + e.radixPointDefinitionSymbol + ";{1," + e.digits + "}]" : i += e.radixPointDefinitionSymbol + ";{" + e.digits + "}")), i += r(e.suffix, e), i += "[-]", e.greedy = !1, i }, placeholder: "", greedy: !1, digits: "*", digitsOptional: !0, enforceDigitsOnBlur: !1, radixPoint: ".", positionCaretOnClick: "radixFocus", groupSize: 3, groupSeparator: "", autoGroup: !1, allowMinus: !0, negationSymbol: { front: "-", back: "" }, integerDigits: "+", integerOptional: !0, prefix: "", suffix: "", rightAlign: !0, decimalProtect: !0, min: null, max: null, step: 1, insertMode: !0, autoUnmask: !1, unmaskAsNumber: !1, inputmode: "numeric", preValidation: function (e, t, a, n, i) { if ("-" === a || a == i.negationSymbol.front) return !0 === i.allowMinus && (i.isNegative = i.isNegative === k || !i.isNegative, "" === e.join("") || { caret: t, dopost: !0 }); if (!1 === n && a === i.radixPoint && i.digits !== k && (isNaN(i.digits) || 0 < parseInt(i.digits))) { var r = v.inArray(i.radixPoint, e); if (-1 !== r) return !0 === i.numericInput ? t === r : { caret: r + 1 } } return !0 }, postValidation: function (e, t, a) { var n = a.suffix.split(""), i = a.prefix.split(""); if (t.pos == k && t.caret !== k && !0 !== t.dopost) return t; var r = t.caret != k ? t.caret : t.pos, o = e.slice(); a.numericInput && (r = o.length - r - 1, o = o.reverse()); var s = o[r]; if (s === a.groupSeparator && (s = o[r += 1]), r == o.length - a.suffix.length - 1 && s === a.radixPoint) return t; s !== k && s !== a.radixPoint && s !== a.negationSymbol.front && s !== a.negationSymbol.back && (o[r] = "?", 0 < a.prefix.length && r >= (!1 === a.isNegative ? 1 : 0) && r < a.prefix.length - 1 + (!1 === a.isNegative ? 1 : 0) ? i[r - (!1 === a.isNegative ? 1 : 0)] = "?" : 0 < a.suffix.length && r >= o.length - a.suffix.length - (!1 === a.isNegative ? 1 : 0) && (n[r - (o.length - a.suffix.length - (!1 === a.isNegative ? 1 : 0))] = "?")), i = i.join(""), n = n.join(""); var l, c, u, p, f = o.join("").replace(i, ""); if (f = (f = (f = (f = f.replace(n, "")).replace(new RegExp(y.escapeRegex(a.groupSeparator), "g"), "")).replace(new RegExp("[-" + y.escapeRegex(a.negationSymbol.front) + "]", "g"), "")).replace(new RegExp(y.escapeRegex(a.negationSymbol.back) + "$"), ""), isNaN(a.placeholder) && (f = f.replace(new RegExp(y.escapeRegex(a.placeholder), "g"), "")), 1 < f.length && 1 !== f.indexOf(a.radixPoint) && ("0" == s && (f = f.replace(/^\?/g, "")), f = f.replace(/^0/g, "")), f.charAt(0) === a.radixPoint && !0 !== a.numericInput && (f = "0" + f), "" !== f) { if (f = f.split(""), (!a.digitsOptional || a.enforceDigitsOnBlur && "blur" === t.event) && isFinite(a.digits)) { var d = v.inArray(a.radixPoint, f), m = v.inArray(a.radixPoint, o); -1 === d && (f.push(a.radixPoint), d = f.length - 1); for (var h = 1; h <= a.digits; h++)a.digitsOptional && (!a.enforceDigitsOnBlur || "blur" !== t.event) || f[d + h] !== k && f[d + h] !== a.placeholder.charAt(0) ? -1 !== m && o[m + h] !== k && (f[d + h] = f[d + h] || o[m + h]) : f[d + h] = t.placeholder || a.placeholder.charAt(0) } !0 !== a.autoGroup || "" === a.groupSeparator || s === a.radixPoint && t.pos === k && !t.dopost ? f = f.join("") : (f = y((u = "", u += "(" + (l = a).groupSeparator + "*{" + l.groupSize + "}){*}", "" !== l.radixPoint && (c = f.join("").split(l.radixPoint))[1] && (u += l.radixPoint + "*{" + c[1].match(/^\d*\??\d*/)[0].length + "}"), u), { numericInput: !0, jitMasking: !0, definitions: { "*": { validator: "[0-9?]", cardinality: 1 } } }).format(f.join(""))).charAt(0) === a.groupSeparator && f.substr(1) } a.isNegative && "blur" === t.event && (a.isNegative = "0" !== f), f = i + f, f += n, a.isNegative && (f = a.negationSymbol.front + f, f += a.negationSymbol.back), f = f.split(""), s !== k && (s !== a.radixPoint && s !== a.negationSymbol.front && s !== a.negationSymbol.back ? -1 < (r = v.inArray("?", f)) ? f[r] = s : r = t.caret || 0 : s !== a.radixPoint && s !== a.negationSymbol.front && s !== a.negationSymbol.back || -1 !== (p = v.inArray(s, f)) && (r = p)), a.numericInput && (r = f.length - r - 1, f = f.reverse()); var g = { caret: s === k || t.pos !== k ? r + (a.numericInput ? -1 : 1) : r, buffer: f, refreshFromBuffer: t.dopost || e.join("") !== f.join("") }; return g.refreshFromBuffer ? g : t }, onBeforeWrite: function (e, t, a, n) { if (e) switch (e.type) { case "keydown": return n.postValidation(t, { caret: a, dopost: !0 }, n); case "blur": case "checkval": var i; if ((r = n).parseMinMaxOptions === k && (null !== r.min && (r.min = r.min.toString().replace(new RegExp(y.escapeRegex(r.groupSeparator), "g"), ""), "," === r.radixPoint && (r.min = r.min.replace(r.radixPoint, ".")), r.min = isFinite(r.min) ? parseFloat(r.min) : NaN, isNaN(r.min) && (r.min = Number.MIN_VALUE)), null !== r.max && (r.max = r.max.toString().replace(new RegExp(y.escapeRegex(r.groupSeparator), "g"), ""), "," === r.radixPoint && (r.max = r.max.replace(r.radixPoint, ".")), r.max = isFinite(r.max) ? parseFloat(r.max) : NaN, isNaN(r.max) && (r.max = Number.MAX_VALUE)), r.parseMinMaxOptions = "done"), null !== n.min || null !== n.max) { if (i = n.onUnMask(t.join(""), k, v.extend({}, n, { unmaskAsNumber: !0 })), null !== n.min && i < n.min) return n.isNegative = n.min < 0, n.postValidation(n.min.toString().replace(".", n.radixPoint).split(""), { caret: a, dopost: !0, placeholder: "0" }, n); if (null !== n.max && i > n.max) return n.isNegative = n.max < 0, n.postValidation(n.max.toString().replace(".", n.radixPoint).split(""), { caret: a, dopost: !0, placeholder: "0" }, n) } return n.postValidation(t, { caret: a, dopost: !0, placeholder: "0", event: "blur" }, n); case "_checkval": return { caret: a } }var r }, regex: { integerPart: function (e, t) { return t ? new RegExp("[" + y.escapeRegex(e.negationSymbol.front) + "+]?") : new RegExp("[" + y.escapeRegex(e.negationSymbol.front) + "+]?\\d+") }, integerNPart: function (e) { return new RegExp("[\\d" + y.escapeRegex(e.groupSeparator) + y.escapeRegex(e.placeholder.charAt(0)) + "]+") } }, definitions: { "~": { validator: function (e, t, a, n, i, r) { var o = n ? new RegExp("[0-9" + y.escapeRegex(i.groupSeparator) + "]").test(e) : new RegExp("[0-9]").test(e); if (!0 === o) { if (!0 !== i.numericInput && t.validPositions[a] !== k && "~" === t.validPositions[a].match.def && !r) { var s = t.buffer.join(""); s = (s = (s = s.replace(new RegExp("[-" + y.escapeRegex(i.negationSymbol.front) + "]", "g"), "")).replace(new RegExp(y.escapeRegex(i.negationSymbol.back) + "$"), "")).replace(/0/g, i.placeholder.charAt(0)); var l = t._buffer.join(""); for (s === i.radixPoint && (s = l); null === s.match(y.escapeRegex(l) + "$");)l = l.slice(1); o = (s = (s = s.replace(l, "")).split(""))[a] === k ? { pos: a, remove: a } : { pos: a } } } else n || e !== i.radixPoint || t.validPositions[a - 1] !== k || (t.buffer[a] = "0", o = { pos: a + 1 }); return o }, cardinality: 1 }, "+": { validator: function (e, t, a, n, i) { return i.allowMinus && ("-" === e || e === i.negationSymbol.front) }, cardinality: 1, placeholder: "" }, "-": { validator: function (e, t, a, n, i) { return i.allowMinus && e === i.negationSymbol.back }, cardinality: 1, placeholder: "" }, ":": { validator: function (e, t, a, n, i) { var r = "[" + y.escapeRegex(i.radixPoint) + "]", o = new RegExp(r).test(e); return o && t.validPositions[a] && t.validPositions[a].match.placeholder === i.radixPoint && (o = { caret: a + 1 }), o }, cardinality: 1, placeholder: function (e) { return e.radixPoint } } }, onUnMask: function (e, t, a) { if ("" === t && !0 === a.nullable) return t; var n = e.replace(a.prefix, ""); return n = (n = n.replace(a.suffix, "")).replace(new RegExp(y.escapeRegex(a.groupSeparator), "g"), ""), "" !== a.placeholder.charAt(0) && (n = n.replace(new RegExp(a.placeholder.charAt(0), "g"), "0")), a.unmaskAsNumber ? ("" !== a.radixPoint && -1 !== n.indexOf(a.radixPoint) && (n = n.replace(y.escapeRegex.call(this, a.radixPoint), ".")), n = (n = n.replace(new RegExp("^" + y.escapeRegex(a.negationSymbol.front)), "-")).replace(new RegExp(y.escapeRegex(a.negationSymbol.back) + "$"), ""), Number(n)) : n }, isComplete: function (e, t) { var a = e.join(""); if (e.slice().join("") !== a) return !1; var n = a.replace(t.prefix, ""); return n = (n = n.replace(t.suffix, "")).replace(new RegExp(y.escapeRegex(t.groupSeparator), "g"), ""), "," === t.radixPoint && (n = n.replace(y.escapeRegex(t.radixPoint), ".")), isFinite(n) }, onBeforeMask: function (e, t) { var a, n; t.isNegative = k, e = e.toString().charAt(e.length - 1) === t.radixPoint ? e.toString().substr(0, e.length - 1) : e.toString(), "" !== t.radixPoint && isFinite(e) && (a = e.split("."), n = "" !== t.groupSeparator ? parseInt(t.groupSize) : 0, 2 === a.length && (a[0].length > n || a[1].length > n || a[0].length <= n && a[1].length < n) && (e = e.replace(".", t.radixPoint))); var i, r, o = e.match(/,/g), s = e.match(/\./g); return e = s && o ? s.length > o.length ? (e = e.replace(/\./g, "")).replace(",", t.radixPoint) : o.length > s.length ? (e = e.replace(/,/g, "")).replace(".", t.radixPoint) : e.indexOf(".") < e.indexOf(",") ? e.replace(/\./g, "") : e = e.replace(/,/g, "") : e.replace(new RegExp(y.escapeRegex(t.groupSeparator), "g"), ""), 0 === t.digits && (-1 !== e.indexOf(".") ? e = e.substring(0, e.indexOf(".")) : -1 !== e.indexOf(",") && (e = e.substring(0, e.indexOf(",")))), "" !== t.radixPoint && isFinite(t.digits) && -1 !== e.indexOf(t.radixPoint) && (i = e.split(t.radixPoint)[1].match(new RegExp("\\d*"))[0], parseInt(t.digits) < i.toString().length && (r = Math.pow(10, parseInt(t.digits)), e = e.replace(y.escapeRegex(t.radixPoint), "."), e = (e = Math.round(parseFloat(e) * r) / r).toString().replace(".", t.radixPoint))), e }, canClearPosition: function (e, t, a, n, i) { var r = e.validPositions[t], o = r.input !== i.radixPoint || null !== e.validPositions[t].match.fn && !1 === i.decimalProtect || r.input === i.radixPoint && e.validPositions[t + 1] && null === e.validPositions[t + 1].match.fn || isFinite(r.input) || t === a || r.input === i.groupSeparator || r.input === i.negationSymbol.front || r.input === i.negationSymbol.back; return !o || "+" != r.match.nativeDef && "-" != r.match.nativeDef || (i.isNegative = !1), o }, onKeyDown: function (e, t, a, n) { var i = v(this); if (e.ctrlKey) switch (e.keyCode) { case y.keyCode.UP: i.val(parseFloat(this.inputmask.unmaskedvalue()) + parseInt(n.step)), i.trigger("setvalue"); break; case y.keyCode.DOWN: i.val(parseFloat(this.inputmask.unmaskedvalue()) - parseInt(n.step)), i.trigger("setvalue") } } }, currency: { prefix: "$ ", groupSeparator: ",", alias: "numeric", placeholder: "0", autoGroup: !0, digits: 2, digitsOptional: !1, clearMaskOnLostFocus: !1 }, decimal: { alias: "numeric" }, integer: { alias: "numeric", digits: 0, radixPoint: "" }, percentage: { alias: "numeric", digits: 2, digitsOptional: !0, radixPoint: ".", placeholder: "0", autoGroup: !1, min: 0, max: 100, suffix: " %", allowMinus: !1 } }) }(), function () { function t(e, t) { var a = (e.mask || e).replace(/#/g, "9").replace(/\)/, "9").replace(/[+()#-]/g, ""), n = (t.mask || t).replace(/#/g, "9").replace(/\)/, "9").replace(/[+()#-]/g, ""), i = (e.mask || e).split("#")[0], r = (t.mask || t).split("#")[0]; return 0 === r.indexOf(i) ? -1 : 0 === i.indexOf(r) ? 1 : a.localeCompare(n) } var o, a, n; o = window.dependencyLib || jQuery, a = window.Inputmask, n = a.prototype.analyseMask, a.prototype.analyseMask = function (l, e, r) { var c = {}; return r.phoneCodes && (r.phoneCodes && 1e3 < r.phoneCodes.length && (function e(t, a, n) { n = n || c, "" !== (a = a || "") && (n[a] = {}); for (var i = "", r = n[a] || n, o = t.length - 1; 0 <= o; o--)r[i = (l = t[o].mask || t[o]).substr(0, 1)] = r[i] || [], r[i].unshift(l.substr(1)), t.splice(o, 1); for (var s in r) 500 < r[s].length && e(r[s].slice(), s, r) }((l = l.substr(1, l.length - 2)).split(r.groupmarker.end + r.alternatormarker + r.groupmarker.start)), l = function e(t) { var a = "", n = []; for (var i in t) o.isArray(t[i]) ? 1 === t[i].length ? n.push(i + t[i]) : n.push(i + r.groupmarker.start + t[i].join(r.groupmarker.end + r.alternatormarker + r.groupmarker.start) + r.groupmarker.end) : n.push(i + e(t[i])); return 1 === n.length ? a += n[0] : a += r.groupmarker.start + n.join(r.groupmarker.end + r.alternatormarker + r.groupmarker.start) + r.groupmarker.end, a }(c)), l = l.replace(/9/g, "\\9")), n.call(this, l, e, r) }, a.extendAliases({ abstractphone: { groupmarker: { start: "<", end: ">" }, countrycode: "", phoneCodes: [], mask: function (e) { return e.definitions = { "#": a.prototype.definitions[9] }, e.phoneCodes.sort(t) }, keepStatic: !0, onBeforeMask: function (e, t) { var a = e.replace(/^0{1,2}/, "").replace(/[\s]/g, ""); return (1 < a.indexOf(t.countrycode) || -1 === a.indexOf(t.countrycode)) && (a = "+" + t.countrycode + a), a }, onUnMask: function (e, t, a) { return t }, inputmode: "tel" } }) }();